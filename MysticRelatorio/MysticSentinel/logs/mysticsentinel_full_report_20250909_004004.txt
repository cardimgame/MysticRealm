[MysticSentinel] Relat√≥rio Completo de C√≥digo-Fonte
Data: 20250909_004004
Arquivos analisados: 4
--------------------------------------------------------------------------------

üìÑ Arquivo: auto_fix.py
üî¢ Linhas: 118
----------------------------------------
import re
import ast
from pathlib import Path
import subprocess

def fix_missing_module(path: Path, module_name: str) -> bool:
    """
    Tenta corrigir ModuleNotFoundError sugerindo instala√ß√£o via pip.
    Retorna True se o m√≥dulo foi instalado com sucesso.
    """
    try:
        print(f"[AutoFix] Tentando instalar m√≥dulo ausente: {module_name}")
        result = subprocess.run(
            [sys.executable, "-m", "pip", "install", module_name],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            print(f"[AutoFix] ‚úÖ M√≥dulo '{module_name}' instalado com sucesso.")
            return True
        else:
            print(f"[AutoFix] ‚ùå Falha ao instalar '{module_name}': {result.stderr}")
            return False
    except Exception as err:
        print(f"[AutoFix] ‚ùå Erro ao tentar instalar '{module_name}': {err}")
        return False

def fix_optional_typing(path: Path) -> bool:
    try:
        content = path.read_text(encoding="utf-8")
    except Exception:
        return False

    changed = False
    patterns = [
        r"Optional\s*\(\s*dict\s*\)",
        r"Optional\s*<\s*dict\s*>",
        r"Optional\s+dict",
    ]
    for pat in patterns:
        if re.search(pat, content):
            content = re.sub(pat, "Optional[dict]", content)
            changed = True

    if "Optional[dict]" in content and "from typing import Optional" not in content:
        content = "from typing import Optional\n" + content
        changed = True

    if changed:
        try:
            path.write_text(content, encoding="utf-8")
            print(f"[AutoFix] Corrigido Optional em: {path}")
            return True
        except Exception:
            return False

    return False

def fix_argument_mismatch(path: Path, func_name: str, expected: int, received: int) -> bool:
    try:
        src = path.read_text(encoding="utf-8")
        tree = ast.parse(src)
    except Exception:
        return False

    changed = False
    lines = src.splitlines()

    for node in ast.walk(tree):
        if isinstance(node, ast.Call) and hasattr(node.func, "id") and node.func.id == func_name:
            arg_count = len(node.args)
            if arg_count == received:
                line_no = node.lineno - 1
                line = lines[line_no]
                new_args = ", ".join(["None"] * expected)
                fixed_line = re.sub(rf"{func_name}\s*\((.*?)\)", f"{func_name}({new_args})", line)
                lines[line_no] = fixed_line
                changed = True

    if changed:
        try:
            path.write_text("\n".join(lines), encoding="utf-8")
            print(f"[AutoFix] Corrigido chamada de '{func_name}' em: {path}")
            return True
        except Exception:
            return False

    return False

def fix_none_attribute(path: Path, attr_name: str) -> bool:
    try:
        lines = path.read_text(encoding="utf-8").splitlines()
    except Exception:
        return False

    changed = False
    new_lines = []
    for i, line in enumerate(lines):
        if f".{attr_name}" in line and "None" not in line:
            match = re.search(r"(\w+)\." + re.escape(attr_name), line)
            if match:
                obj_name = match.group(1)
                indent = re.match(r"\s*", line).group(0)
                new_lines.append(f"{indent}if {obj_name} is not None:")
                new_lines.append(indent + "    " + line.strip())
                changed = True
                continue
        new_lines.append(line)

    if changed:
        try:
            path.write_text("\n".join(new_lines), encoding="utf-8")
            print(f"[AutoFix] Verifica√ß√£o de None adicionada em: {path}")
            return True
        except Exception:
            return False

    return False


================================================================================

üìÑ Arquivo: generate_mysticsentinel_full_report.py
üî¢ Linhas: 38
----------------------------------------
from pathlib import Path
from datetime import datetime

BASE_DIR = Path(__file__).parent  # MysticSentinel/
LOG_DIR = BASE_DIR / "logs"
LOG_DIR.mkdir(exist_ok=True)

def generate_full_report():
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_path = LOG_DIR / f"mysticsentinel_full_report_{timestamp}.txt"

    py_files = sorted(BASE_DIR.glob("*.py"))
    report_lines = [
        f"[MysticSentinel] Relat√≥rio Completo de C√≥digo-Fonte",
        f"Data: {timestamp}",
        f"Arquivos analisados: {len(py_files)}",
        "-" * 80
    ]

    for file in py_files:
        report_lines.append(f"\nüìÑ Arquivo: {file.name}")
        report_lines.append(f"üî¢ Linhas: {sum(1 for _ in file.open(encoding='utf-8'))}")
        report_lines.append("-" * 40)
        try:
            content = file.read_text(encoding="utf-8")
            report_lines.append(content)
        except Exception as e:
            report_lines.append(f"[Erro ao ler o arquivo: {e}]")
        report_lines.append("\n" + "=" * 80)

    with open(report_path, "w", encoding="utf-8") as f:
        f.write("\n".join(report_lines))

    print(f"\n‚úÖ Relat√≥rio completo gerado: {report_path}")

if __name__ == "__main__":
    generate_full_report()
# -*- coding: utf-8 -*-

================================================================================

üìÑ Arquivo: report.py
üî¢ Linhas: 36
----------------------------------------
import json
from pathlib import Path
import time

LOG_DIR = Path(__file__).parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

def generate_report(error_type: str, message: str, traceback_str: str, file_path: Path, fixed: bool):
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    report_data = {
        "timestamp": timestamp,
        "error_type": error_type,
        "message": message,
        "file": str(file_path),
        "correction_applied": fixed,
        "traceback": traceback_str
    }

    # Salva como JSON
    json_path = LOG_DIR / f"report_{timestamp}.json"
    with open(json_path, "w", encoding="utf-8") as f:
        json.dump(report_data, f, indent=2, ensure_ascii=False)

    # Salva como TXT
    txt_path = LOG_DIR / f"report_{timestamp}.txt"
    with open(txt_path, "w", encoding="utf-8") as f:
        f.write(f"[MysticSentinel] Relat√≥rio de Erro\n")
        f.write(f"Timestamp: {timestamp}\n")
        f.write(f"Arquivo: {file_path}\n")
        f.write(f"Tipo: {error_type}\n")
        f.write(f"Mensagem: {message}\n")
        f.write(f"Corre√ß√£o autom√°tica: {'‚úÖ aplicada' if fixed else '‚ùå n√£o aplicada'}\n")
        f.write("Traceback:\n")
        f.write(traceback_str)

    print(f"[MysticSentinel] Relat√≥rio salvo em:\n- {json_path}\n- {txt_path}")


================================================================================

üìÑ Arquivo: sentinel.py
üî¢ Linhas: 91
----------------------------------------
import traceback
import time
import os
import sys
import re
import json
from pathlib import Path
from MysticRelatorio.MysticSentinel.auto_fix import (
    fix_optional_typing,
    fix_argument_mismatch,
    fix_none_attribute,
    fix_missing_module
)
from MysticRelatorio.MysticSentinel.report import generate_report

LOG_DIR = Path(__file__).parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

CONFIG_PATH = Path(__file__).parent / "config.json"
try:
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        CONFIG = json.load(f)
except Exception:
    CONFIG = {}

def color(text, code): return f"\033[{code}m{text}\033[0m"

def run_with_guard(main_func):
    try:
        main_func()
    except Exception as e:
        tb = traceback.format_exc()
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        log_file = LOG_DIR / f"error_{timestamp}.txt"

        # Extrai caminho do arquivo onde ocorreu o erro
        lines = tb.splitlines()
        file_path = None
        for line in lines:
            if "File" in line and ", line" in line:
                parts = line.split('"')
                if len(parts) > 1:
                    file_path = Path(parts[1])
                    break

        fixed = False
        if CONFIG.get("auto_fix_enabled", True) and file_path and file_path.exists():
            # Corre√ß√£o de Optional
            if CONFIG.get("fixers", {}).get("optional_typing", True):
                fixed |= fix_optional_typing(file_path)

            # Corre√ß√£o de argumentos faltando
            if isinstance(e, TypeError) and "missing" in str(e):
                if CONFIG.get("fixers", {}).get("argument_mismatch", True):
                    match = re.search(r"(\w+)\(\) missing (\d+) required .*?argument", str(e))
                    if match:
                        func_name = match.group(1)
                        missing_args = int(match.group(2))
                        fixed |= fix_argument_mismatch(file_path, func_name, expected=missing_args + 1, received=missing_args)

            # Corre√ß√£o de atributo em NoneType
            if isinstance(e, AttributeError) and "'NoneType' object has no attribute" in str(e):
                if CONFIG.get("fixers", {}).get("none_attribute", True):
                    match = re.search(r"has no attribute '(\w+)'", str(e))
                    if match:
                        attr_name = match.group(1)
                        fixed |= fix_none_attribute(file_path, attr_name)
            # Corre√ß√£o de m√≥dulo ausente
            if isinstance(e, ModuleNotFoundError):
                if CONFIG.get("fixers", {}).get("missing_module", True):
                    match = re.search(r"No module named '(\w+)'", str(e))
                    if match:
                        module_name = match.group(1)
                        fixed |= fix_missing_module(file_path, module_name)

        # Gera relat√≥rio
        generate_report(
            error_type=type(e).__name__,
            message=str(e),
            traceback_str=tb,
            file_path=file_path if file_path else Path("desconhecido"),
            fixed=fixed
        )

        print("\n" + color("[MysticSentinel] ‚ö†Ô∏è Erro capturado", "94"))  # Azul
        print(color(f"Tipo: {type(e).__name__}", "91"))  # Vermelho
        print(color(f"Mensagem: {str(e)}", "91"))
        if file_path:
            print(color(f"Arquivo afetado: {file_path}", "90"))  # Cinza
        print(color(f"[AutoFix] {'‚úÖ Corre√ß√£o autom√°tica aplicada' if fixed else '‚ùå Corre√ß√£o n√£o aplicada'}", "92" if fixed else "93"))
        print(color("[MysticSentinel] O jogo foi encerrado com seguran√ßa.", "94"))


================================================================================