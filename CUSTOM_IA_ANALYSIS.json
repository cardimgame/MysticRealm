{
  "timestamp": 1757124130.2718756,
  "files": [
    {
      "path": "core\\asset.py",
      "loc": 38,
      "classes": [],
      "functions": [
        {
          "name": "_mark_missing",
          "args": [
            "path"
          ],
          "decorators": [],
          "start_line": 10,
          "end_line": 12,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "missing_assets",
          "args": [],
          "decorators": [],
          "start_line": 14,
          "end_line": 15,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "load_image_strict",
          "args": [
            "rel_path"
          ],
          "decorators": [],
          "start_line": 17,
          "end_line": 23,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "load_scaled",
          "args": [
            "rel_path",
            "size",
            "smooth"
          ],
          "decorators": [],
          "start_line": 25,
          "end_line": 37,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "pygame",
        "typing",
        "core.config"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame\nfrom pygame import Surface\nfrom typing import List, Tuple\nfrom core.config import ASSETS_DIR\n\n_missing: List[str] = []\n_cache: dict[str, Surface] = {}\n\ndef _mark_missing(path: str):\n    if path not in _missing:\n        _missing.append(path)\n\ndef missing_assets() -> List[str]:\n    return list(_missing)\n\ndef load_image_strict(rel_path: str) -> Surface | None:\n    path = ASSETS_DIR / rel_path\n    if not path.exists():\n        _mark_missing(str(path))\n        return None\n    img = pygame.image.load(str(path))\n    return img.convert_alpha() if img.get_alpha() else img.convert()\n\ndef load_scaled(rel_path: str, size: Tuple[int, int], smooth: bool = False) -> Surface | None:\n    key = f\"{rel_path}|{size}|{'s' if smooth else 'n'}\"\n    if key in _cache:\n        return _cache[key]\n    img = load_image_strict(rel_path)\n    if img is None:\n        return None\n    if img.get_size() == size:\n        _cache[key] = img\n        return img\n    out = pygame.transform.smoothscale(img, size) if smooth else pygame.transform.scale(img, size)\n    _cache[key] = out\n    return out\n"
    },
    {
      "path": "core\\asset_manager.py",
      "loc": 24,
      "classes": [],
      "functions": [
        {
          "name": "get",
          "args": [
            "key"
          ],
          "decorators": [],
          "start_line": 14,
          "end_line": 23,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "typing",
        "pygame",
        "core.asset"
      ],
      "uses_pygame": true,
      "source_code": "from typing import Optional\nimport pygame\nfrom core.asset import load_image_strict\n\nPATHS = {\n    'ui.dragons_bg': 'ui/dragons_bg.png',\n    'ui.main_bg': 'ui/main_menu.png',\n    'ui.selection_arrow': 'ui/selection_arrow.png',\n    'ui.selection_player': 'ui/selection_player.png',\n}\n\n_cache: dict[str, pygame.Surface] = {}\n\ndef get(key: str) -> Optional[pygame.Surface]:\n    if key in _cache:\n        return _cache[key]\n    rel = PATHS.get(key)\n    if not rel:\n        return None\n    img = load_image_strict(rel)\n    if img is not None:\n        _cache[key] = img\n    return img\n"
    },
    {
      "path": "core\\camera.py",
      "loc": 37,
      "classes": [
        {
          "name": "Camera",
          "start_line": 4,
          "end_line": 36,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "screen_width",
                "screen_height",
                "world_width",
                "world_height"
              ],
              "decorators": [],
              "start_line": 5,
              "end_line": 11,
              "draw_suspect": false
            },
            {
              "name": "get_rect",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 13,
              "end_line": 14,
              "draw_suspect": false
            },
            {
              "name": "world_to_screen",
              "args": [
                "self",
                "pos"
              ],
              "decorators": [],
              "start_line": 16,
              "end_line": 18,
              "draw_suspect": false
            },
            {
              "name": "move_to",
              "args": [
                "self",
                "x",
                "y"
              ],
              "decorators": [],
              "start_line": 20,
              "end_line": 24,
              "draw_suspect": false
            },
            {
              "name": "center_on",
              "args": [
                "self",
                "world_pos"
              ],
              "decorators": [],
              "start_line": 26,
              "end_line": 27,
              "draw_suspect": false
            },
            {
              "name": "follow",
              "args": [
                "self",
                "target_rect",
                "smooth"
              ],
              "decorators": [],
              "start_line": 29,
              "end_line": 33,
              "draw_suspect": false
            },
            {
              "name": "on_resize",
              "args": [
                "self",
                "w",
                "h"
              ],
              "decorators": [],
              "start_line": 35,
              "end_line": 36,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "screen_width",
            "screen_height",
            "world_width",
            "world_height"
          ],
          "decorators": [],
          "start_line": 5,
          "end_line": 11,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "get_rect",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 13,
          "end_line": 14,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "world_to_screen",
          "args": [
            "self",
            "pos"
          ],
          "decorators": [],
          "start_line": 16,
          "end_line": 18,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "move_to",
          "args": [
            "self",
            "x",
            "y"
          ],
          "decorators": [],
          "start_line": 20,
          "end_line": 24,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "center_on",
          "args": [
            "self",
            "world_pos"
          ],
          "decorators": [],
          "start_line": 26,
          "end_line": 27,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "follow",
          "args": [
            "self",
            "target_rect",
            "smooth"
          ],
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "on_resize",
          "args": [
            "self",
            "w",
            "h"
          ],
          "decorators": [],
          "start_line": 35,
          "end_line": 36,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame\n\nclass Camera:\n    def __init__(self, screen_width: int, screen_height: int, world_width: int = 4096, world_height: int = 4096):\n        self.screen_w = int(screen_width)\n        self.screen_h = int(screen_height)\n        self.world_w = int(world_width)\n        self.world_h = int(world_height)\n        self.x = 0.0\n        self.y = 0.0\n\n    def get_rect(self) -> pygame.Rect:\n        return pygame.Rect(int(self.x), int(self.y), self.screen_w, self.screen_h)\n\n    def world_to_screen(self, pos):\n        x, y = pos\n        return (int(x - self.x), int(y - self.y))\n\n    def move_to(self, x: float, y: float):\n        max_x = max(0, self.world_w - self.screen_w)\n        max_y = max(0, self.world_h - self.screen_h)\n        self.x = min(max(0, x), max_x)\n        self.y = min(max(0, y), max_y)\n\n    def center_on(self, world_pos: tuple[int, int]):\n        self.move_to(world_pos[0] - self.screen_w // 2, world_pos[1] - self.screen_h // 2)\n\n    def follow(self, target_rect: pygame.Rect, smooth: float = 0.12):\n        tx, ty = target_rect.center\n        goal_x = tx - self.screen_w // 2\n        goal_y = ty - self.screen_h // 2\n        self.move_to(self.x + (goal_x - self.x) * smooth, self.y + (goal_y - self.y) * smooth)\n\n    def on_resize(self, w: int, h: int):\n        self.screen_w, self.screen_h = int(w), int(h)\n"
    },
    {
      "path": "core\\camera_v2.py",
      "loc": 92,
      "classes": [
        {
          "name": "CameraV2",
          "start_line": 4,
          "end_line": 92,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "screen_w",
                "screen_h",
                "world_w",
                "world_h"
              ],
              "decorators": [],
              "start_line": 5,
              "end_line": 18,
              "draw_suspect": false
            },
            {
              "name": "set_profile",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 20,
              "end_line": 24,
              "draw_suspect": false
            },
            {
              "name": "get_rect",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 26,
              "end_line": 27,
              "draw_suspect": false
            },
            {
              "name": "world_to_screen",
              "args": [
                "self",
                "pos"
              ],
              "decorators": [],
              "start_line": 29,
              "end_line": 33,
              "draw_suspect": false
            },
            {
              "name": "center_on",
              "args": [
                "self",
                "world_pt"
              ],
              "decorators": [],
              "start_line": 35,
              "end_line": 39,
              "draw_suspect": false
            },
            {
              "name": "apply_shake",
              "args": [
                "self",
                "power"
              ],
              "decorators": [],
              "start_line": 41,
              "end_line": 43,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 45,
              "end_line": 80,
              "draw_suspect": false
            },
            {
              "name": "_clamp",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 82,
              "end_line": 88,
              "draw_suspect": false
            },
            {
              "name": "on_resize",
              "args": [
                "self",
                "w",
                "h"
              ],
              "decorators": [],
              "start_line": 90,
              "end_line": 92,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "screen_w",
            "screen_h",
            "world_w",
            "world_h"
          ],
          "decorators": [],
          "start_line": 5,
          "end_line": 18,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "set_profile",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 20,
          "end_line": 24,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "get_rect",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 26,
          "end_line": 27,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "world_to_screen",
          "args": [
            "self",
            "pos"
          ],
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "center_on",
          "args": [
            "self",
            "world_pt"
          ],
          "decorators": [],
          "start_line": 35,
          "end_line": 39,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "apply_shake",
          "args": [
            "self",
            "power"
          ],
          "decorators": [],
          "start_line": 41,
          "end_line": 43,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 45,
          "end_line": 80,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_clamp",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 82,
          "end_line": 88,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "on_resize",
          "args": [
            "self",
            "w",
            "h"
          ],
          "decorators": [],
          "start_line": 90,
          "end_line": 92,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "math",
        "pygame"
      ],
      "uses_pygame": false,
      "source_code": "# core/camera_v2.py\nimport math, pygame\n\nclass CameraV2:\n    def __init__(self, screen_w, screen_h, world_w, world_h, *, zoom=1.0):\n        self.screen_w, self.screen_h = int(screen_w), int(screen_h)\n        self.world_w, self.world_h = int(world_w), int(world_h)\n        self.x = 0.0\n        self.y = 0.0\n        self.zoom = float(zoom)\n        # Parâmetros padrão (Exploração):\n        self.dead_frac = (0.38, 0.30)  # fração da tela (w,h)\n        self.lookahead_t = 0.25        # segundos de antecipação\n        self.smooth = 0.12             # amortecimento (0.10~0.16)\n        # Shake (opcional)\n        self.shake_amp = 0.0\n        self.shake_t = 0.0\n        self.shake_decay = 4.0\n\n    def set_profile(self, *, dead_frac=None, lookahead_t=None, smooth=None, zoom=None):\n        if dead_frac is not None: self.dead_frac = dead_frac\n        if lookahead_t is not None: self.lookahead_t = lookahead_t\n        if smooth is not None: self.smooth = smooth\n        if zoom is not None: self.zoom = zoom\n\n    def get_rect(self) -> pygame.Rect:\n        return pygame.Rect(int(self.x), int(self.y), self.screen_w, self.screen_h)\n\n    def world_to_screen(self, pos):\n        wx, wy = float(pos[0]), float(pos[1])\n        sx = int((wx - self.x) * self.zoom)\n        sy = int((wy - self.y) * self.zoom)\n        return sx, sy\n\n    def center_on(self, world_pt):\n        cx, cy = world_pt\n        self.x = cx - (self.screen_w / (2*self.zoom))\n        self.y = cy - (self.screen_h / (2*self.zoom))\n        self._clamp()\n\n    def apply_shake(self, power: float = 8.0):\n        self.shake_amp = max(self.shake_amp, power)\n        self.shake_t = 0.0\n\n    def update(self, dt: float, *, focus_px, vel_px):\n        # 1) foco com lookahead\n        fx, fy = focus_px\n        vx, vy = vel_px\n        fx += vx * self.lookahead_t\n        fy += vy * self.lookahead_t\n\n        # 2) deadzone central\n        dz_w = self.screen_w * self.dead_frac[0]\n        dz_h = self.screen_h * self.dead_frac[1]\n        dz = pygame.Rect(\n            int(self.x + (self.screen_w - dz_w)/2),\n            int(self.y + (self.screen_h - dz_h)/2),\n            int(dz_w), int(dz_h)\n        )\n        dest_x, dest_y = self.x, self.y\n        if fx < dz.left:   dest_x -= (dz.left - fx)\n        if fx > dz.right:  dest_x += (fx - dz.right)\n        if fy < dz.top:    dest_y -= (dz.top - fy)\n        if fy > dz.bottom: dest_y += (fy - dz.bottom)\n\n        # 3) suavização exponencial (lerp amortecido)\n        self.x += (dest_x - self.x) * self.smooth\n        self.y += (dest_y - self.y) * self.smooth\n\n        # 4) shake (decay)\n        if self.shake_amp > 0.01:\n            self.shake_t += dt\n            amp = self.shake_amp * math.exp(-self.shake_decay * self.shake_t)\n            ox = math.sin(self.shake_t*62.0) * amp\n            oy = math.cos(self.shake_t*50.0) * amp\n            self.x += ox; self.y += oy\n            if amp < 0.1: self.shake_amp = 0.0\n\n        # 5) limites\n        self._clamp()\n\n    def _clamp(self):\n        view_w = self.screen_w / self.zoom\n        view_h = self.screen_h / self.zoom\n        max_x = max(0.0, self.world_w - view_w)\n        max_y = max(0.0, self.world_h - view_h)\n        self.x = min(max(0.0, self.x), max_x)\n        self.y = min(max(0.0, self.y), max_y)\n\n    def on_resize(self, w: int, h: int):\n        self.screen_w, self.screen_h = int(w), int(h)\n        self._clamp()"
    },
    {
      "path": "core\\config.py",
      "loc": 28,
      "classes": [],
      "functions": [],
      "imports": [
        "pathlib"
      ],
      "uses_pygame": false,
      "source_code": "\nfrom pathlib import Path\n\nFPS: int = 60\nSCREEN_SIZE = (1280, 720)\n\nTILE_W: int = 64\nTILE_H: int = 32\n\nPLAYER_SIZE: int = 128\nPLAYER_SPEED_TILES: float = 3.0\nPLAYER_SPEED: float = 220.0\n\nBASE_DIR = Path(__file__).resolve().parents[1]\nASSETS_DIR = BASE_DIR / 'assets'\nASSETS_DIR.mkdir(parents=True, exist_ok=True)\nSAVES_DIR = BASE_DIR / 'saves'\nSAVES_DIR.mkdir(parents=True, exist_ok=True)\nSETTINGS_PATH = BASE_DIR / 'settings.json'\n\nDEFAULT_ASSET_SUBFOLDERS = [\n    ASSETS_DIR / 'ground',\n    ASSETS_DIR / 'ui',\n    ASSETS_DIR / 'player',\n    ASSETS_DIR / 'actors',\n]\nfor d in DEFAULT_ASSET_SUBFOLDERS: d.mkdir(parents=True, exist_ok=True)\n"
    },
    {
      "path": "core\\input.py",
      "loc": 27,
      "classes": [],
      "functions": [
        {
          "name": "actions_from_events",
          "args": [
            "events"
          ],
          "decorators": [],
          "start_line": 13,
          "end_line": 20,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "axes_from_pressed",
          "args": [],
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame"
      ],
      "uses_pygame": true,
      "source_code": "# core/input.py\nimport pygame\n\nKEYMAP = {\n    \"up\":    (pygame.K_w, pygame.K_UP),\n    \"down\":  (pygame.K_s, pygame.K_DOWN),\n    \"left\":  (pygame.K_a, pygame.K_LEFT),\n    \"right\": (pygame.K_d, pygame.K_RIGHT),\n    \"confirm\": (pygame.K_RETURN, pygame.K_SPACE),\n    \"back\":  (pygame.K_ESCAPE,),\n}\n\ndef actions_from_events(events):\n    actions = set()\n    for e in events:\n        if e.type == pygame.KEYDOWN:\n            for action, keys in KEYMAP.items():\n                if e.key in keys:\n                    actions.add(action)\n    return actions\n\ndef axes_from_pressed():\n    pressed = pygame.key.get_pressed()\n    x = (pressed[pygame.K_d] or pressed[pygame.K_RIGHT]) - (pressed[pygame.K_a] or pressed[pygame.K_LEFT])\n    y = (pressed[pygame.K_s] or pressed[pygame.K_DOWN]) - (pressed[pygame.K_w] or pressed[pygame.K_UP])\n    return x, y\n"
    },
    {
      "path": "core\\props.py",
      "loc": 72,
      "classes": [
        {
          "name": "PropSprite",
          "start_line": 46,
          "end_line": 54,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "key",
                "x",
                "y",
                "collidable"
              ],
              "decorators": [],
              "start_line": 47,
              "end_line": 52,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen",
                "camera"
              ],
              "decorators": [],
              "start_line": 53,
              "end_line": 54,
              "draw_suspect": false
            }
          ]
        },
        {
          "name": "PropsManager",
          "start_line": 56,
          "end_line": 71,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 57,
              "end_line": 59,
              "draw_suspect": false
            },
            {
              "name": "clear",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 60,
              "end_line": 61,
              "draw_suspect": false
            },
            {
              "name": "add_prop",
              "args": [
                "self",
                "key",
                "x",
                "y",
                "collidable"
              ],
              "decorators": [],
              "start_line": 62,
              "end_line": 65,
              "draw_suspect": false
            },
            {
              "name": "add_props_from_list",
              "args": [
                "self",
                "items"
              ],
              "decorators": [],
              "start_line": 66,
              "end_line": 68,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen",
                "camera",
                "sort_by_y"
              ],
              "decorators": [],
              "start_line": 69,
              "end_line": 71,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "_guess_subdir_for_key",
          "args": [
            "key"
          ],
          "decorators": [],
          "start_line": 19,
          "end_line": 23,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "load_prop_image",
          "args": [
            "key"
          ],
          "decorators": [],
          "start_line": 25,
          "end_line": 44,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "__init__",
          "args": [
            "self",
            "key",
            "x",
            "y",
            "collidable"
          ],
          "decorators": [],
          "start_line": 47,
          "end_line": 52,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen",
            "camera"
          ],
          "decorators": [],
          "start_line": 53,
          "end_line": 54,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        },
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 57,
          "end_line": 59,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "clear",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 60,
          "end_line": 61,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "add_prop",
          "args": [
            "self",
            "key",
            "x",
            "y",
            "collidable"
          ],
          "decorators": [],
          "start_line": 62,
          "end_line": 65,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "add_props_from_list",
          "args": [
            "self",
            "items"
          ],
          "decorators": [],
          "start_line": 66,
          "end_line": 68,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen",
            "camera",
            "sort_by_y"
          ],
          "decorators": [],
          "start_line": 69,
          "end_line": 71,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "__future__",
        "os",
        "pygame",
        "typing"
      ],
      "uses_pygame": false,
      "source_code": "\nfrom __future__ import annotations\nimport os, pygame\nfrom typing import Optional, List, Dict\n\nASSETS_ROOT = os.path.join('assets','tiles')\nPREFIX_TO_SUBDIR: Dict[str, str] = {\n    'tree_': os.path.join(ASSETS_ROOT,'trees'),\n    'rock_': os.path.join(ASSETS_ROOT,'props'),\n    'log_': os.path.join(ASSETS_ROOT,'props'),\n    'bush_': os.path.join(ASSETS_ROOT,'props'),\n    'flower_': os.path.join(ASSETS_ROOT,'props'),\n    'fence_': os.path.join(ASSETS_ROOT,'props'),\n    'sign_': os.path.join(ASSETS_ROOT,'props'),\n    'house_': os.path.join(ASSETS_ROOT,'village'),\n}\n_IMAGE_CACHE: Dict[str, 'pygame.Surface'] = {}\n\ndef _guess_subdir_for_key(key: str) -> Optional[str]:\n    k = key.lower()\n    for p, sub in PREFIX_TO_SUBDIR.items():\n        if k.startswith(p): return sub\n    return None\n\ndef load_prop_image(key: str) -> 'pygame.Surface':\n    if key in _IMAGE_CACHE: return _IMAGE_CACHE[key]\n    sub = _guess_subdir_for_key(key)\n    surf = None\n    if sub:\n        for ext in ('.png','.jpg','.jpeg'):\n            path = os.path.join(sub, key + ext)\n            if os.path.exists(path):\n                img = pygame.image.load(path)\n                surf = img.convert_alpha() if img.get_alpha() else img.convert()\n                break\n    if surf is None:\n        surf = pygame.Surface((64,64), pygame.SRCALPHA)\n        surf.fill((255,0,255,120))\n        try:\n            f = pygame.font.SysFont('arial', 12)\n            surf.blit(f.render(key[:10], True, (0,0,0)), (4,4))\n        except Exception: pass\n    _IMAGE_CACHE[key] = surf\n    return surf\n\nclass PropSprite(pygame.sprite.Sprite):\n    def __init__(self, key: str, x: int, y: int, collidable: bool=True):\n        super().__init__()\n        self.key = key\n        self.image: 'pygame.Surface' = load_prop_image(key)\n        self.rect = self.image.get_rect(topleft=(int(x), int(y)))\n        self.collidable = bool(collidable)\n    def draw(self, screen: 'pygame.Surface', camera):\n        screen.blit(self.image, camera.world_to_screen(self.rect.topleft))\n\nclass PropsManager:\n    def __init__(self):\n        self.all = pygame.sprite.Group()\n        self.collidable_props = pygame.sprite.Group()\n    def clear(self):\n        self.all.empty(); self.collidable_props.empty()\n    def add_prop(self, key: str, x: int, y: int, collidable: bool=True):\n        sp = PropSprite(key, x, y, collidable)\n        self.all.add(sp)\n        if sp.collidable: self.collidable_props.add(sp)\n    def add_props_from_list(self, items: List[Dict]):\n        for it in items or []:\n            self.add_prop(it.get('key','unknown'), it.get('x',0), it.get('y',0), it.get('collidable',True))\n    def draw(self, screen: 'pygame.Surface', camera, sort_by_y: bool=False):\n        sprites = sorted(self.all.sprites(), key=lambda s: s.rect.bottom) if sort_by_y else self.all.sprites()\n        for s in sprites: s.draw(screen, camera)\n"
    },
    {
      "path": "core\\renderer.py",
      "loc": 19,
      "classes": [
        {
          "name": "Renderer",
          "start_line": 4,
          "end_line": 18,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 5,
              "end_line": 6,
              "draw_suspect": false
            },
            {
              "name": "clear",
              "args": [
                "self",
                "color"
              ],
              "decorators": [],
              "start_line": 8,
              "end_line": 9,
              "draw_suspect": false
            },
            {
              "name": "draw_layers",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 11,
              "end_line": 18,
              "draw_suspect": true
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 5,
          "end_line": 6,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "clear",
          "args": [
            "self",
            "color"
          ],
          "decorators": [],
          "start_line": 8,
          "end_line": 9,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw_layers",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 11,
          "end_line": 18,
          "draw_suspect": true,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame"
      ],
      "uses_pygame": true,
      "source_code": "# core/renderer.py\nimport pygame\n\nclass Renderer:\n    def __init__(self, screen: pygame.Surface):\n        self.screen = screen\n\n    def clear(self, color=(16, 16, 24)):\n        self.screen.fill(color)\n\n    def draw_layers(self, *, ground=(), props=(), entities=(), fx=(), ui=()):\n        for layer in (ground, props, entities, fx, ui):\n            for item in layer:\n                if callable(item):\n                    item(self.screen)\n                else:\n                    surf, pos = item\n                    self.screen.blit(surf, pos)\n"
    },
    {
      "path": "core\\scene.py",
      "loc": 37,
      "classes": [
        {
          "name": "Scene",
          "start_line": 6,
          "end_line": 36,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "manager",
                "screen_size"
              ],
              "decorators": [],
              "start_line": 7,
              "end_line": 13,
              "draw_suspect": false
            },
            {
              "name": "on_resize",
              "args": [
                "self",
                "new_size"
              ],
              "decorators": [],
              "start_line": 15,
              "end_line": 16,
              "draw_suspect": false
            },
            {
              "name": "handle_events",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 18,
              "end_line": 19,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 21,
              "end_line": 26,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 28,
              "end_line": 36,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "manager",
            "screen_size"
          ],
          "decorators": [],
          "start_line": 7,
          "end_line": 13,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "on_resize",
          "args": [
            "self",
            "new_size"
          ],
          "decorators": [],
          "start_line": 15,
          "end_line": 16,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle_events",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 18,
          "end_line": 19,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": true
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 21,
          "end_line": 26,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 28,
          "end_line": 36,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "props"
      ],
      "uses_pygame": true,
      "source_code": "\n# core/scene.py — Cena base com draw corrigido para usar world_to_screen\nimport pygame\nfrom .props import PropsManager\n\nclass Scene:\n    def __init__(self, manager, screen_size=(1280,720)):\n        self.manager = manager\n        self.screen_width, self.screen_height = screen_size\n        self.props_manager = PropsManager()\n        self.player = None\n        self.camera = None\n        self.weather = None\n\n    def on_resize(self, new_size):\n        self.screen_width, self.screen_height = new_size\n\n    def handle_events(self, events):\n        pass\n\n    def update(self, dt):\n        if self.weather:\n            try:\n                self.weather.update(dt)\n            except TypeError:\n                self.weather.update()\n\n    def draw(self, screen: pygame.Surface):\n        if self.camera:\n            self.props_manager.draw(screen, self.camera)\n        if self.player and self.camera:\n            # Converter coordenadas de mundo para a tela via câmera\n            screen.blit(self.player.image,\n                        self.camera.world_to_screen(self.player.rect.topleft))\n        if self.weather:\n            self.weather.draw(screen)\n"
    },
    {
      "path": "core\\settings.py",
      "loc": 28,
      "classes": [],
      "functions": [
        {
          "name": "load_settings",
          "args": [],
          "decorators": [],
          "start_line": 14,
          "end_line": 24,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "save_settings",
          "args": [
            "data"
          ],
          "decorators": [],
          "start_line": 26,
          "end_line": 27,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "json",
        "core.config"
      ],
      "uses_pygame": false,
      "source_code": "\nimport json\nfrom core.config import SETTINGS_PATH\nDEFAULTS = {\n  'volume': 100,\n  'mute': False,\n  'resolution': [1280, 720],\n  'fps': 60,\n  'difficulty': 'normal',\n  'language': 'en-US',\n  'show_missing': False,\n}\n\ndef load_settings() -> dict:\n    if SETTINGS_PATH.exists():\n        try:\n            data = json.loads(SETTINGS_PATH.read_text(encoding='utf-8'))\n            out = DEFAULTS.copy()\n            out.update({k: v for k, v in data.items()})\n            return out\n        except Exception:\n            pass\n    save_settings(DEFAULTS)\n    return DEFAULTS.copy()\n\ndef save_settings(data: dict):\n    SETTINGS_PATH.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding='utf-8')\n"
    },
    {
      "path": "core\\state_manager.py",
      "loc": 14,
      "classes": [
        {
          "name": "StateManager",
          "start_line": 2,
          "end_line": 13,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 3,
              "end_line": 5,
              "draw_suspect": false
            },
            {
              "name": "switch_to",
              "args": [
                "self",
                "new_scene"
              ],
              "decorators": [],
              "start_line": 6,
              "end_line": 13,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 3,
          "end_line": 5,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "switch_to",
          "args": [
            "self",
            "new_scene"
          ],
          "decorators": [],
          "start_line": 6,
          "end_line": 13,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [],
      "uses_pygame": false,
      "source_code": "\nclass StateManager:\n    def __init__(self):\n        self.current_scene = None\n        self.running = True\n    def switch_to(self, new_scene):\n        if self.current_scene and hasattr(self.current_scene, 'exit'):\n            try: self.current_scene.exit()\n            except Exception: pass\n        self.current_scene = new_scene\n        if hasattr(self.current_scene, 'enter'):\n            try: self.current_scene.enter()\n            except Exception: pass\n"
    },
    {
      "path": "core\\strings.py",
      "loc": 189,
      "classes": [],
      "functions": [
        {
          "name": "t",
          "args": [
            "key",
            "lang"
          ],
          "decorators": [],
          "start_line": 187,
          "end_line": 188,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "typing"
      ],
      "uses_pygame": false,
      "source_code": "\n# core/strings.py — i18n (en-US, pt-BR) centralized UI strings (Zip 3)\nfrom typing import Any\n\nSTRINGS: dict[str, dict[str, Any]] = {\n  'en-US': {\n    # MAIN & CAMPAIGN\n    'main.continue': 'Continue',\n    'main.options': ['Campaign', 'Settings', 'Exit'],\n    'campaign.options': ['New Game', 'Load Game', 'Delete Game', 'Back'],\n\n    # SAVES\n    'saves.title.load': 'Load Game',\n    'saves.title.delete': 'Delete Game',\n    'saves.title.save': 'Save Game',\n    'saves.hint': 'ENTER to select • ESC back',\n    'saves.slot': 'Slot',\n    'saves.available': 'Available',\n    'saves.empty': 'Empty',\n    'saves.deleted': 'Deleted.',\n\n    # SETTINGS\n    'settings.title': 'Settings',\n    'settings.back': 'Back',\n    'settings.show_missing': 'Show Missing Overlay',\n    'settings.resolution': 'Resolution',\n    'settings.fps': 'FPS',\n    'settings.audio': 'Audio',\n    'settings.mute': 'Mute',\n    'settings.difficulty': 'Difficulty',\n    'settings.controls': 'Controls',\n    'settings.language': 'Language',\n    'settings.lang.values': ['English (US)', 'Português (Brasil)'],\n\n    # CHARACTER CREATION (Phase 1 Complete)\n    'char.titles': ['Choose Gender', 'Choose Race', 'Choose Class', 'Choose Constellation', 'Choose 2 Skills', 'Enter Name', 'Summary'],\n    'char.hint.nav': '←/→ to change • ENTER confirm • ESC back',\n    'char.hint.name': 'ENTER confirm • ESC back',\n    'char.hint.summary': 'ENTER to start • ESC to edit',\n    'char.hint.skills': '←/→ navigate • ENTER select/deselect • Need 2 skills • ESC back',\n\n    # CONSTELLATIONS (Birthsigns)\n    'signs.list': ['The Blade','The Veil','The Aether','The Beast'],\n    'signs.desc.The Blade': '+10% physical damage, +1 STR',\n    'signs.desc.The Veil': '+10% stealth, +1 DEX',\n    'signs.desc.The Aether': '+10% Magicka, +1 INT',\n    'signs.desc.The Beast': '+10% Stamina, +1 END',\n\n    # SKILLS (names)\n    'skills.list': ['One-Handed','Two-Handed','Archery','Stealth','Conjuration','Elemental Magic'],\n\n    # HUD / UI\n    'hud.gold': 'Gold',\n    'ui.inventory': 'INVENTORY',\n    'ui.paused': 'PAUSED (ESC to resume)',\n\n    # PAUSE TABS\n    'pause.tabs': ['Continue', 'Inventory', 'Settings', 'Save', 'Exit to Menu'],\n\n    # DEBUG\n    'debug.missing': 'ATTENTION: missing assets (using placeholders):',\n\n    # RACES (by id from systems.stats)\n    'race.Norther.name': 'Norther',\n    'race.Norther.desc': 'Humans from frozen lands; robust and cold-resistant.',\n    'race.Valen.name': 'Valen',\n    'race.Valen.desc': 'Elves of ancient woods; keen eyes and light steps.',\n    'race.Durn.name': 'Durn',\n    'race.Durn.desc': 'Dwarves of the mountains; masters of forge and tenacity.',\n    'race.Serathi.name': 'Serathi',\n    'race.Serathi.desc': 'Nomadic felines; quick instincts and stealth.',\n    'race.Aetherborn.name': 'Aetherborn',\n    'race.Aetherborn.desc': 'Born of aether; natural affinity with magic.',\n\n    # CLASSES (keys from systems.stats)\n    'class.Guerreiro.name': 'Warrior',\n    'class.Guerreiro.desc': 'Melee combat, heavy armor.',\n    'class.Arqueiro.name': 'Archer',\n    'class.Arqueiro.desc': 'Ranged attacks, mobility.',\n    'class.Arcanista.name': 'Arcanist',\n    'class.Arcanista.desc': 'Scholarly mages, mystic power.',\n    'class.Viajante.name': 'Wayfarer',\n    'class.Viajante.desc': 'Versatile, survival and trade.',\n    'class.Sombra.name': 'Shade',\n    'class.Sombra.desc': 'Stealth and assassination.',\n    'class.Guardiã(o).name': 'Guardian',\n    'class.Guardiã(o).desc': 'Protection, faith and discipline.',\n\n    # Compass POIs\n    'poi.village': 'Village',\n    'poi.lake': 'Lake',\n    'poi.cave': 'Cave',\n    'poi.peak': 'Peak',\n  },\n\n  'pt-BR': {\n    # MAIN & CAMPAIGN\n    'main.continue': 'Continuar',\n    'main.options': ['Campanha', 'Configurações', 'Sair'],\n    'campaign.options': ['Novo Jogo', 'Carregar Jogo', 'Excluir Jogo', 'Voltar'],\n\n    # SAVES\n    'saves.title.load': 'Carregar Jogo',\n    'saves.title.delete': 'Excluir Jogo',\n    'saves.title.save': 'Salvar Jogo',\n    'saves.hint': 'ENTER seleciona • ESC volta',\n    'saves.slot': 'Slot',\n    'saves.available': 'Disponível',\n    'saves.empty': 'Vazio',\n    'saves.deleted': 'Excluído.',\n\n    # SETTINGS\n    'settings.title': 'Configurações',\n    'settings.back': 'Voltar',\n    'settings.show_missing': 'Mostrar Aviso de Assets Ausentes',\n    'settings.resolution': 'Resolução',\n    'settings.fps': 'FPS',\n    'settings.audio': 'Áudio',\n    'settings.mute': 'Mudo',\n    'settings.difficulty': 'Dificuldade',\n    'settings.controls': 'Controles',\n    'settings.language': 'Idioma',\n    'settings.lang.values': ['English (US)', 'Português (Brasil)'],\n\n    # CHARACTER CREATION\n    'char.titles': ['Escolher Gênero', 'Escolher Raça', 'Escolher Classe', 'Escolher Constelação', 'Escolher 2 Perícias', 'Digitar Nome', 'Resumo'],\n    'char.hint.nav': '←/→ altera • ENTER confirma • ESC volta',\n    'char.hint.name': 'ENTER confirma • ESC volta',\n    'char.hint.summary': 'ENTER inicia • ESC edita',\n    'char.hint.skills': '←/→ navega • ENTER seleciona/deseleciona • Precisa de 2 • ESC volta',\n\n    # CONSTELLATIONS\n    'signs.list': ['A Lâmina','O Véu','O Éter','A Fera'],\n    'signs.desc.The Blade': '+10% dano físico, +1 FOR',\n    'signs.desc.The Veil': '+10% furtividade, +1 DES',\n    'signs.desc.The Aether': '+10% Magicka, +1 INT',\n    'signs.desc.The Beast': '+10% Stamina, +1 VIG',\n\n    # SKILLS\n    'skills.list': ['Uma Mão','Duas Mãos','Arco','Furtividade','Conjuração','Magia Elemental'],\n\n    # HUD / UI\n    'hud.gold': 'Ouro',\n    'ui.inventory': 'INVENTÁRIO',\n    'ui.paused': 'PAUSADO (ESC para continuar)',\n\n    # PAUSE TABS\n    'pause.tabs': ['Continuar', 'Inventário', 'Configurações', 'Salvar', 'Sair para o Menu'],\n\n    # DEBUG\n    'debug.missing': 'ATENÇÃO: assets ausentes (usando placeholders):',\n\n    # RACES\n    'race.Norther.name': 'Norther',\n    'race.Norther.desc': 'Humanos das terras geladas; robustos e resistentes ao frio.',\n    'race.Valen.name': 'Valen',\n    'race.Valen.desc': 'Elfos de bosques antigos; olhos aguçados e passos leves.',\n    'race.Durn.name': 'Durn',\n    'race.Durn.desc': 'Anões das montanhas; mestres da forja e da tenacidade.',\n    'race.Serathi.name': 'Serathi',\n    'race.Serathi.desc': 'Felinos nômades; instintos rápidos e furtivos.',\n    'race.Aetherborn.name': 'Aetherborn',\n    'race.Aetherborn.desc': 'Nascidos do éter; afinidade natural com magia.',\n\n    # CLASSES\n    'class.Guerreiro.name': 'Guerreiro',\n    'class.Guerreiro.desc': 'Combate corpo a corpo, armaduras pesadas.',\n    'class.Arqueiro.name': 'Arqueiro',\n    'class.Arqueiro.desc': 'Ataques à distância, mobilidade.',\n    'class.Arcanista.name': 'Arcanista',\n    'class.Arcanista.desc': 'Magos eruditos, poder místico.',\n    'class.Viajante.name': 'Viajante',\n    'class.Viajante.desc': 'Versátil, sobrevivência e comércio.',\n    'class.Sombra.name': 'Sombra',\n    'class.Sombra.desc': 'Furtividade e assassinato.',\n    'class.Guardiã(o).name': 'Guardiã(o)',\n    'class.Guardiã(o).desc': 'Proteção, fé e disciplina.',\n\n    # Compass POIs\n    'poi.village': 'Vila',\n    'poi.lake': 'Lago',\n    'poi.cave': 'Caverna',\n    'poi.peak': 'Pico',\n  }\n}\n\ndef t(key: str, lang: str = 'en-US'):\n    return STRINGS.get(lang, {}).get(key, STRINGS.get('en-US', {}).get(key, key))\n"
    },
    {
      "path": "core\\tilemap.py",
      "loc": 95,
      "classes": [
        {
          "name": "IsoTileSet",
          "start_line": 10,
          "end_line": 31,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 11,
              "end_line": 12,
              "draw_suspect": false
            },
            {
              "name": "_try_load_disk",
              "args": [
                "self",
                "token"
              ],
              "decorators": [],
              "start_line": 14,
              "end_line": 21,
              "draw_suspect": false
            },
            {
              "name": "get",
              "args": [
                "self",
                "token"
              ],
              "decorators": [],
              "start_line": 23,
              "end_line": 31,
              "draw_suspect": false
            }
          ]
        },
        {
          "name": "IsoMap",
          "start_line": 34,
          "end_line": 95,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "layers",
                "tileset"
              ],
              "decorators": [],
              "start_line": 35,
              "end_line": 44,
              "draw_suspect": false
            },
            {
              "name": "world_bounds",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 46,
              "end_line": 50,
              "draw_suspect": false
            },
            {
              "name": "_get_cam_rect_world",
              "args": [
                "self",
                "camera"
              ],
              "decorators": [],
              "start_line": 52,
              "end_line": 64,
              "draw_suspect": false
            },
            {
              "name": "draw_visible",
              "args": [
                "self",
                "screen",
                "camera"
              ],
              "decorators": [],
              "start_line": 66,
              "end_line": 95,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 11,
          "end_line": 12,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_try_load_disk",
          "args": [
            "self",
            "token"
          ],
          "decorators": [],
          "start_line": 14,
          "end_line": 21,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "get",
          "args": [
            "self",
            "token"
          ],
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "__init__",
          "args": [
            "self",
            "layers",
            "tileset"
          ],
          "decorators": [],
          "start_line": 35,
          "end_line": 44,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "world_bounds",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 46,
          "end_line": 50,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_get_cam_rect_world",
          "args": [
            "self",
            "camera"
          ],
          "decorators": [],
          "start_line": 52,
          "end_line": 64,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw_visible",
          "args": [
            "self",
            "screen",
            "camera"
          ],
          "decorators": [],
          "start_line": 66,
          "end_line": 95,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "os",
        "pygame",
        "core.config",
        "systems.iso_math",
        "systems.tile_factory"
      ],
      "uses_pygame": true,
      "source_code": "# core/tilemap_iso.py\nimport os\nimport pygame\nfrom core.config import TILE_W, TILE_H, ASSETS_DIR\nfrom systems.iso_math import grid_to_screen\n\nGROUND_DIRS = [ASSETS_DIR / 'ground']\n\n\nclass IsoTileSet:\n    def __init__(self):\n        self.cache: dict[str, pygame.Surface] = {}\n\n    def _try_load_disk(self, token: str) -> pygame.Surface | None:\n        \"\"\"Tenta carregar token.png das pastas de ground.\"\"\"\n        for d in GROUND_DIRS:\n            p = d / f\"{token}.png\"\n            if p.exists():\n                img = pygame.image.load(str(p))\n                return img.convert_alpha() if img.get_alpha() else img.convert()\n        return None\n\n    def get(self, token: str) -> pygame.Surface:\n        if token in self.cache:\n            return self.cache[token]\n        img = self._try_load_disk(token)\n        if img is None:\n            from systems.tile_factory import build_tile  # fallback procedural\n            img = build_tile(token)\n        self.cache[token] = img\n        return img\n\n\nclass IsoMap:\n    def __init__(self, layers: list[dict], tileset: IsoTileSet):\n        self.layers = layers\n        self.tileset = tileset\n        self.rows = len(layers[0]['grid']) if layers else 0\n        self.cols = len(layers[0]['grid'][0]) if self.rows > 0 else 0\n\n        # OFFSET: garante mundo todo em coordenadas não-negativas (x>=0)\n        # Em projeção losango comum, x_min ≈ -(rows-1)*(TILE_W/2).\n        self.offset_x = (self.rows - 1) * (TILE_W // 2)\n        self.offset_y = 0\n\n    def world_bounds(self) -> tuple[int, int]:\n        \"\"\"Dimensão teórica do losango projetado (sem considerar zoom).\"\"\"\n        w = (self.cols + self.rows) * (TILE_W // 2)\n        h = (self.cols + self.rows) * (TILE_H // 2)\n        return int(w), int(h)\n\n    def _get_cam_rect_world(self, camera) -> pygame.Rect:\n        \"\"\"\n        Retângulo da câmera em UNIDADES DE MUNDO.\n        Se a câmera tem 'zoom', ajusta a largura/altura para world-space (screen/zoom).\n        \"\"\"\n        if hasattr(camera, \"zoom\"):\n            view_w = int(camera.screen_w / max(0.0001, float(camera.zoom)))\n            view_h = int(camera.screen_h / max(0.0001, float(camera.zoom)))\n            return pygame.Rect(int(camera.x), int(camera.y), view_w, view_h)\n        return camera.get_rect() if hasattr(camera, \"get_rect\") else pygame.Rect(\n            getattr(camera, \"x\", 0), getattr(camera, \"y\", 0),\n            getattr(camera, \"screen_w\", 0), getattr(camera, \"screen_h\", 0)\n        )\n\n    def draw_visible(self, screen: pygame.Surface, camera):\n        if not self.layers:\n            return\n\n        cam = self._get_cam_rect_world(camera)\n        pad_x, pad_y = TILE_W, TILE_H\n        view = cam.inflate(pad_x * 2, pad_y * 2)\n\n        # Determina as células visíveis com offset aplicado\n        visible_cells: list[tuple[int, int, int, int]] = []\n        for r in range(self.rows):\n            for c in range(self.cols):\n                x, y = grid_to_screen(r, c)\n                x += self.offset_x\n                y += self.offset_y\n                if (x + TILE_W > view.x and x < view.right and\n                    y + TILE_H > view.y and y < view.bottom):\n                    visible_cells.append((r, c, x, y))\n\n        # Ordem de desenho (fundo->frente)\n        visible_cells.sort(key=lambda t: (t[0] + t[1], t[0]))\n\n        for layer in self.layers:\n            grid = layer['grid']\n            for r, c, x, y in visible_cells:\n                token = grid[r][c]\n                if not token:\n                    continue\n                img = self.tileset.get(token)\n                screen.blit(img, camera.world_to_screen((x, y)))"
    },
    {
      "path": "core\\tilemap_iso.py",
      "loc": 99,
      "classes": [
        {
          "name": "IsoTileSet",
          "start_line": 10,
          "end_line": 31,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 11,
              "end_line": 12,
              "draw_suspect": false
            },
            {
              "name": "_try_load_disk",
              "args": [
                "self",
                "token"
              ],
              "decorators": [],
              "start_line": 14,
              "end_line": 21,
              "draw_suspect": false
            },
            {
              "name": "get",
              "args": [
                "self",
                "token"
              ],
              "decorators": [],
              "start_line": 23,
              "end_line": 31,
              "draw_suspect": false
            }
          ]
        },
        {
          "name": "IsoMap",
          "start_line": 34,
          "end_line": 98,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "layers",
                "tileset"
              ],
              "decorators": [],
              "start_line": 35,
              "end_line": 43,
              "draw_suspect": false
            },
            {
              "name": "world_bounds",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 45,
              "end_line": 49,
              "draw_suspect": false
            },
            {
              "name": "_get_cam_rect_world",
              "args": [
                "self",
                "camera"
              ],
              "decorators": [],
              "start_line": 51,
              "end_line": 63,
              "draw_suspect": false
            },
            {
              "name": "draw_visible",
              "args": [
                "self",
                "screen",
                "camera"
              ],
              "decorators": [],
              "start_line": 65,
              "end_line": 94,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen",
                "camera"
              ],
              "decorators": [],
              "start_line": 96,
              "end_line": 98,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 11,
          "end_line": 12,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_try_load_disk",
          "args": [
            "self",
            "token"
          ],
          "decorators": [],
          "start_line": 14,
          "end_line": 21,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "get",
          "args": [
            "self",
            "token"
          ],
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "__init__",
          "args": [
            "self",
            "layers",
            "tileset"
          ],
          "decorators": [],
          "start_line": 35,
          "end_line": 43,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "world_bounds",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 45,
          "end_line": 49,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_get_cam_rect_world",
          "args": [
            "self",
            "camera"
          ],
          "decorators": [],
          "start_line": 51,
          "end_line": 63,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw_visible",
          "args": [
            "self",
            "screen",
            "camera"
          ],
          "decorators": [],
          "start_line": 65,
          "end_line": 94,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen",
            "camera"
          ],
          "decorators": [],
          "start_line": 96,
          "end_line": 98,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "os",
        "pygame",
        "core.config",
        "systems.iso_math",
        "systems.tile_factory"
      ],
      "uses_pygame": true,
      "source_code": "# core/tilemap_iso.py\nimport os\nimport pygame\nfrom core.config import TILE_W, TILE_H, ASSETS_DIR\nfrom systems.iso_math import grid_to_screen\n\nGROUND_DIRS = [ASSETS_DIR / 'ground']\n\n\nclass IsoTileSet:\n    def __init__(self):\n        self.cache: dict[str, pygame.Surface] = {}\n\n    def _try_load_disk(self, token: str) -> pygame.Surface | None:\n        \"\"\"Tenta carregar token.png das pastas de ground.\"\"\"\n        for d in GROUND_DIRS:\n            p = d / f\"{token}.png\"\n            if p.exists():\n                img = pygame.image.load(str(p))\n                return img.convert_alpha() if img.get_alpha() else img.convert()\n        return None\n\n    def get(self, token: str) -> pygame.Surface:\n        if token in self.cache:\n            return self.cache[token]\n        img = self._try_load_disk(token)\n        if img is None:\n            from systems.tile_factory import build_tile  # fallback procedural\n            img = build_tile(token)\n        self.cache[token] = img\n        return img\n\n\nclass IsoMap:\n    def __init__(self, layers: list[dict], tileset: IsoTileSet):\n        self.layers = layers\n        self.tileset = tileset\n        self.rows = len(layers[0]['grid']) if layers else 0\n        self.cols = len(layers[0]['grid'][0]) if self.rows > 0 else 0\n\n        # OFFSET: garante mundo todo em coordenadas não-negativas (x>=0)\n        self.offset_x = (self.rows - 1) * (TILE_W // 2)\n        self.offset_y = 0\n\n    def world_bounds(self) -> tuple[int, int]:\n        \"\"\"Dimensão teórica do losango projetado (sem considerar zoom).\"\"\"\n        w = (self.cols + self.rows) * (TILE_W // 2)\n        h = (self.cols + self.rows) * (TILE_H // 2)\n        return int(w), int(h)\n\n    def _get_cam_rect_world(self, camera) -> pygame.Rect:\n        \"\"\"\n        Retângulo da câmera em UNIDADES DE MUNDO.\n        Se a câmera tem 'zoom', ajusta a largura/altura para world-space (screen/zoom).\n        \"\"\"\n        if hasattr(camera, \"zoom\"):\n            view_w = int(camera.screen_w / max(0.0001, float(camera.zoom)))\n            view_h = int(camera.screen_h / max(0.0001, float(camera.zoom)))\n            return pygame.Rect(int(camera.x), int(camera.y), view_w, view_h)\n        return camera.get_rect() if hasattr(camera, \"get_rect\") else pygame.Rect(\n            getattr(camera, \"x\", 0), getattr(camera, \"y\", 0),\n            getattr(camera, \"screen_w\", 0), getattr(camera, \"screen_h\", 0)\n        )\n\n    def draw_visible(self, screen: pygame.Surface, camera):\n        if not self.layers:\n            return\n\n        cam = self._get_cam_rect_world(camera)\n        pad_x, pad_y = TILE_W, TILE_H\n        view = cam.inflate(pad_x * 2, pad_y * 2)\n\n        # Determina as células visíveis com offset aplicado\n        visible_cells: list[tuple[int, int, int, int]] = []\n        for r in range(self.rows):\n            for c in range(self.cols):\n                x, y = grid_to_screen(r, c)\n                x += self.offset_x\n                y += self.offset_y\n                if (x + TILE_W > view.x and x < view.right and\n                    y + TILE_H > view.y and y < view.bottom):\n                    visible_cells.append((r, c, x, y))\n\n        # Ordem de desenho (fundo->frente)\n        visible_cells.sort(key=lambda t: (t[0] + t[1], t[0]))\n\n        for layer in self.layers:\n            grid = layer['grid']\n            for r, c, x, y in visible_cells:\n                token = grid[r][c]\n                if not token:\n                    continue\n                img = self.tileset.get(token)\n                screen.blit(img, camera.world_to_screen((x, y)))\n\n    def draw(self, screen: pygame.Surface, camera):\n        \"\"\"Compatibilidade: chama draw_visible internamente.\"\"\"\n        self.draw_visible(screen, camera)\n"
    },
    {
      "path": "core\\ui_fx.py",
      "loc": 105,
      "classes": [
        {
          "name": "FlameFX",
          "start_line": 87,
          "end_line": 104,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "hotspots",
                "radius"
              ],
              "decorators": [],
              "start_line": 88,
              "end_line": 91,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 92,
              "end_line": 93,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 94,
              "end_line": 104,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "blit_fit",
          "args": [
            "screen",
            "img"
          ],
          "decorators": [],
          "start_line": 4,
          "end_line": 16,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "blit_cover",
          "args": [
            "screen",
            "img"
          ],
          "decorators": [],
          "start_line": 18,
          "end_line": 30,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "make_vignette",
          "args": [
            "size",
            "strength",
            "color"
          ],
          "decorators": [],
          "start_line": 32,
          "end_line": 56,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "make_grain",
          "args": [
            "size",
            "intensity",
            "seed"
          ],
          "decorators": [],
          "start_line": 58,
          "end_line": 69,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "tint",
          "args": [
            "screen",
            "color",
            "alpha"
          ],
          "decorators": [],
          "start_line": 71,
          "end_line": 75,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_make_flame_disc",
          "args": [
            "radius",
            "color",
            "alpha"
          ],
          "decorators": [],
          "start_line": 79,
          "end_line": 85,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "__init__",
          "args": [
            "self",
            "hotspots",
            "radius"
          ],
          "decorators": [],
          "start_line": 88,
          "end_line": 91,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 92,
          "end_line": 93,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 94,
          "end_line": 104,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "random",
        "math"
      ],
      "uses_pygame": true,
      "source_code": "# core/ui_fx.py — versão sem NumPy/surfarray (compatível com Pygame puro)\nimport pygame, random, math\n\ndef blit_fit(screen: pygame.Surface, img: pygame.Surface):\n    \"\"\"Ajusta a imagem à tela com letterbox/pillarbox (sem cortar).\"\"\"\n    sw, sh = screen.get_size()\n    iw, ih = img.get_size()\n    if iw == 0 or ih == 0:\n        return\n    scale = min(sw/iw, sh/ih)\n    nw, nh = int(iw*scale), int(ih*scale)\n    x = (sw - nw)//2\n    y = (sh - nh)//2\n    if (nw, nh) != (iw, ih):\n        img = pygame.transform.smoothscale(img, (nw, nh))\n    screen.blit(img, (x, y))\n\ndef blit_cover(screen: pygame.Surface, img: pygame.Surface):\n    \"\"\"Cobre 100% da tela mantendo proporção (corta excessos).\"\"\"\n    sw, sh = screen.get_size()\n    iw, ih = img.get_size()\n    if iw == 0 or ih == 0:\n        return\n    scale = max(sw/iw, sh/ih)\n    nw, nh = int(iw*scale), int(ih*scale)\n    x = (sw - nw)//2\n    y = (sh - nh)//2\n    if (nw, nh) != (iw, ih):\n        img = pygame.transform.smoothscale(img, (nw, nh))\n    screen.blit(img, (x, y))\n\ndef make_vignette(size, strength=0.65, color=(0,0,0)):\n    \"\"\"\n    Vinheta sem NumPy:\n    - Gera um gradiente radial pequeno (256x256) e faz smoothscale para o tamanho da tela.\n    - Criado só quando a resolução muda.\n    \"\"\"\n    w, h = size\n    base_n = 256\n    g = pygame.Surface((base_n, base_n), pygame.SRCALPHA)\n    cx = cy = base_n / 2.0\n    maxd = math.hypot(cx, cy)\n    for y in range(base_n):\n        dy = (y - cy)\n        for x in range(base_n):\n            dx = (x - cx)\n            d = math.hypot(dx, dy) / maxd  # 0 centro -> 1 borda\n            a = int(255 * max(0.0, min(1.0, (d ** 1.5) * strength)))\n            if a > 0:\n                g.set_at((x, y), (0, 0, 0, a))\n    tint_surf = pygame.Surface((base_n, base_n), pygame.SRCALPHA)\n    tint_surf.fill((*color, 255))\n    g.blit(tint_surf, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)\n    if (w, h) != (base_n, base_n):\n        g = pygame.transform.smoothscale(g, (w, h))\n    return g\n\ndef make_grain(size, intensity=24, seed=None):\n    \"\"\"Granulado leve aleatório.\"\"\"\n    w, h = size\n    rnd = random.Random(seed)\n    surf = pygame.Surface((w, h), pygame.SRCALPHA)\n    dots = max(1, int(w*h*0.01))\n    for _ in range(dots):\n        x = rnd.randrange(0, w); y = rnd.randrange(0, h)\n        g = 120 + rnd.randrange(-intensity, intensity+1)\n        a = 16 + rnd.randrange(0, 24)\n        surf.set_at((x, y), (g, g, g, a))\n    return surf\n\ndef tint(screen: pygame.Surface, color=(32, 42, 64), alpha=40):\n    \"\"\"Véu colorido simples por cima da tela.\"\"\"\n    veil = pygame.Surface(screen.get_size(), pygame.SRCALPHA)\n    veil.fill((*color, int(alpha)))\n    screen.blit(veil, (0, 0))\n\n# FX opcional de “chama” para hotspots (não obrigatório)\n\ndef _make_flame_disc(radius=160, color=(255,140,40), alpha=140):\n    surf = pygame.Surface((radius*2, radius*2), pygame.SRCALPHA)\n    cx = cy = radius\n    for r in range(radius, 0, -1):\n        a = int(alpha * (r / radius) ** 1.8)\n        pygame.draw.circle(surf, (*color, a), (cx, cy), r)\n    return surf\n\nclass FlameFX:\n    def __init__(self, hotspots=None, radius=160):\n        self.hotspots = list(hotspots or [])\n        self.base = _make_flame_disc(radius)\n        self.t = 0.0\n    def update(self, dt: float):\n        self.t += dt\n    def draw(self, screen: pygame.Surface):\n        sw, sh = screen.get_size()\n        for i, (xf, yf) in enumerate(self.hotspots):\n            ox = int(8 * math.sin(self.t*3.0 + i*0.7))\n            oy = int(6 * math.sin(self.t*2.2 + i*1.3))\n            scale = 1.0 + 0.06 * math.sin(self.t*5.0 + i*0.9)\n            w = int(self.base.get_width() * scale)\n            h = int(self.base.get_height() * scale)\n            layer = pygame.transform.smoothscale(self.base, (w, h))\n            rect = layer.get_rect(center=(int(sw*xf) + ox, int(sh*yf) + oy))\n            screen.blit(layer, rect, special_flags=pygame.BLEND_ADD)\n"
    },
    {
      "path": "core\\utils.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "core\\__init__.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "\"\"\"Package\"\"\"\n"
    },
    {
      "path": "gameplay\\actor_sprites.py",
      "loc": 100,
      "classes": [],
      "functions": [
        {
          "name": "_try_load_strip",
          "args": [
            "base_dir",
            "state",
            "size",
            "max_frames"
          ],
          "decorators": [],
          "start_line": 25,
          "end_line": 35,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_make_placeholder_frame",
          "args": [
            "step",
            "size",
            "body",
            "accent",
            "skin"
          ],
          "decorators": [],
          "start_line": 38,
          "end_line": 59,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_build_placeholder_anim",
          "args": [
            "clazz",
            "race",
            "size"
          ],
          "decorators": [],
          "start_line": 62,
          "end_line": 72,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "build_actor_sprites",
          "args": [
            "profile",
            "size"
          ],
          "decorators": [],
          "start_line": 75,
          "end_line": 99,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "typing",
        "os",
        "pygame",
        "typing",
        "core.asset",
        "core.config"
      ],
      "uses_pygame": true,
      "source_code": "from typing import Optional\n# gameplay/actor_sprites.py — FINAL FIX: normalização de path no Windows (\\ -> /)\nimport os\nimport pygame\nfrom typing import Dict, List, Tuple, Optional\nfrom core.asset import load_scaled\nfrom core.config import PLAYER_SIZE\n\nCLASS_COLORS = {\n    'Guerreiro': ((90, 150, 200), (180, 60, 50)),\n    'Arqueiro': ((90, 120, 60), (120, 180, 90)),\n    'Arcanista': ((120, 90, 200), (50, 180, 220)),\n    'Viajante': ((90, 120, 90), (120, 120, 120)),\n    'Sombra': ((80, 80, 80), (200, 40, 40)),\n    'Guardiã(o)': ((200, 200, 220), (200, 170, 60)),\n}\n\nSKIN_BY_RACE = {\n    'Humano': (226, 200, 170),\n    'Elfo': (210, 195, 160),\n    'Anão': (198, 170, 140),\n    'Orc': (130, 170, 120),\n}\n\ndef _try_load_strip(base_dir: str, state: str, size: Tuple[int, int], max_frames=8) -> List[pygame.Surface]:\n    frames: List[pygame.Surface] = []\n    for i in range(max_frames):\n        rel = os.path.join(base_dir, f\"{state}_{i}.png\")\n        rel_norm = rel.replace('\\\\', '/')\n        surf = load_scaled(rel_norm, size, smooth=True)\n        if surf is not None:\n            frames.append(surf)\n        else:\n            break\n    return frames\n\n\ndef _make_placeholder_frame(step: int, size=(PLAYER_SIZE, PLAYER_SIZE),\n                            body=(60, 140, 255), accent=(200, 180, 60), skin=(230, 210, 180)) -> pygame.Surface:\n    w, h = size\n    surf = pygame.Surface((w, h), pygame.SRCALPHA)\n    shadow_w, shadow_h = int(w * 0.5), int(h * 0.18)\n    sh = pygame.Surface((shadow_w, shadow_h), pygame.SRCALPHA)\n    pygame.draw.ellipse(sh, (0, 0, 0, 60), (0, 0, shadow_w, shadow_h))\n    surf.blit(sh, (w // 2 - shadow_w // 2, h - shadow_h - 8))\n    pygame.draw.rect(surf, body, (w // 2 - 20, h // 2 - 10, 40, 48), border_radius=10)\n    head_off = 1 if (step % 2) == 0 else 0\n    pygame.draw.circle(surf, skin, (w // 2, h // 2 - 22 - head_off), 12)\n    cape_y = h // 2 - 2 + (step % 2)\n    pygame.draw.polygon(surf, accent, [\n        (w // 2 - 24, cape_y), (w // 2 + 24, cape_y), (w // 2 + 16, h - 18), (w // 2 - 16, h - 18)\n    ])\n    arm_off = 4 if (step % 2) == 0 else -4\n    pygame.draw.rect(surf, (40, 40, 50), (w // 2 - 30, h // 2 - 6 + arm_off, 10, 26), border_radius=4)\n    pygame.draw.rect(surf, (40, 40, 50), (w // 2 + 20, h // 2 - 6 - arm_off, 10, 26), border_radius=4)\n    leg_off = 4 if (step % 2) == 0 else -2\n    pygame.draw.rect(surf, (40, 40, 50), (w // 2 - 8, h // 2 + 26 + leg_off, 8, 14), border_radius=3)\n    pygame.draw.rect(surf, (40, 40, 50), (w // 2 + 2, h // 2 + 26 - leg_off, 8, 14), border_radius=3)\n    return surf\n\n\ndef _build_placeholder_anim(clazz: str, race: str, size=(PLAYER_SIZE, PLAYER_SIZE)) -> Dict[str, List[pygame.Surface]]:\n    body, accent = CLASS_COLORS.get(clazz, ((60, 140, 255), (200, 180, 60)))\n    skin = SKIN_BY_RACE.get(race, (230, 210, 180))\n    walk = [_make_placeholder_frame(i, size, body, accent, skin) for i in range(4)]\n    run = [_make_placeholder_frame(i, size, body, accent, skin) for i in range(4)]\n    attack = []\n    for i in range(4):\n        f = _make_placeholder_frame(i, size, body, accent, skin)\n        pygame.draw.rect(f, (200, 60, 60), (f.get_width() // 2 + 18, f.get_height() // 2 - 18, 12, 36), border_radius=5)\n        attack.append(f)\n    return {'idle': [walk[0]], 'walk': walk, 'run': run, 'attack': attack}\n\n\ndef build_actor_sprites(profile: Optional[dict], size=(PLAYER_SIZE, PLAYER_SIZE)) -> Dict[str, List[pygame.Surface]]:\n    profile = profile or {}\n    race = profile.get('race', 'Humano')\n    gender = profile.get('gender', 'Masculino')\n    clazz = profile.get('clazz', 'Guerreiro')\n    base = f\"actors/{race}/{gender}/{clazz}\".replace('\\\\', '/')\n    states = ['idle', 'walk', 'run', 'attack']\n    anim: Dict[str, List[pygame.Surface]] = {}\n    found_any = False\n    for st in states:\n        frames = _try_load_strip(base, st, size, max_frames=8)\n        if frames:\n            anim[st] = frames\n            found_any = True\n    if not found_any:\n        return _build_placeholder_anim(clazz, race, size)\n    if 'idle' not in anim:\n        anim['idle'] = [anim.get('walk', [])[0] if anim.get('walk') else _build_placeholder_anim(clazz, race, size)['idle'][0]]\n    if 'walk' not in anim:\n        anim['walk'] = anim['idle']\n    if 'run' not in anim:\n        anim['run'] = anim['walk']\n    if 'attack' not in anim:\n        anim['attack'] = anim['walk']\n    return anim\n"
    },
    {
      "path": "gameplay\\char_create.py",
      "loc": 246,
      "classes": [
        {
          "name": "SceneCharCreate",
          "start_line": 30,
          "end_line": 245,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "mgr",
                "on_complete"
              ],
              "decorators": [],
              "start_line": 31,
              "end_line": 51,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 53,
              "end_line": 113,
              "draw_suspect": false
            },
            {
              "name": "_signs",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 115,
              "end_line": 116,
              "draw_suspect": false
            },
            {
              "name": "_skills_localized",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 118,
              "end_line": 119,
              "draw_suspect": false
            },
            {
              "name": "_build_final_stats",
              "args": [
                "self",
                "race",
                "clazz"
              ],
              "decorators": [],
              "start_line": 121,
              "end_line": 152,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 154,
              "end_line": 158,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 160,
              "end_line": 245,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "mgr",
            "on_complete"
          ],
          "decorators": [],
          "start_line": 31,
          "end_line": 51,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 53,
          "end_line": 113,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_signs",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 115,
          "end_line": 116,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_skills_localized",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 118,
          "end_line": 119,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_build_final_stats",
          "args": [
            "self",
            "race",
            "clazz"
          ],
          "decorators": [],
          "start_line": 121,
          "end_line": 152,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 154,
          "end_line": 158,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 160,
          "end_line": 245,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "systems.stats",
        "core.config",
        "core.asset_manager",
        "core.settings",
        "core.strings",
        "core.ui_fx",
        "ui.theme",
        "gameplay.scene_mainmenu"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame\nfrom systems.stats import RACES, CLASSES, build_stats\nfrom core.config import SCREEN_SIZE\nfrom core.asset_manager import get as assets_get\nfrom core.settings import load_settings\nfrom core.strings import t\nfrom core.ui_fx import blit_cover\nfrom ui.theme import get_font\n\nGENDERS = ['Masculino', 'Feminino']\n\n# Bonus application helpers\nSIGN_BONUS = {\n    'The Blade': {'STR': 1, 'MP%': 0, 'STA%': 0, 'DMG%': 0.10},\n    'The Veil':  {'DEX': 1, 'MP%': 0, 'STA%': 0, 'STEALTH%': 0.10},\n    'The Aether':{'INT': 1, 'MP%': 0.10, 'STA%': 0, 'DMG%': 0},\n    'The Beast': {'END': 1, 'MP%': 0, 'STA%': 0.10, 'DMG%': 0},\n}\nSKILL_LIST = ['One-Handed','Two-Handed','Archery','Stealth','Conjuration','Elemental Magic']\nSKILL_BONUS = {\n    'One-Handed': {'STR': 1},\n    'Two-Handed': {'STR': 1},\n    'Archery': {'DEX': 1},\n    'Stealth': {'DEX': 1},\n    'Conjuration': {'INT': 1},\n    'Elemental Magic': {'INT': 1},\n}\n\nclass SceneCharCreate:\n    def __init__(self, mgr, on_complete):\n        self.mgr = mgr\n        self.on_complete = on_complete\n        self.font = get_font(36)\n        self.small = get_font(22)\n        self.bg = assets_get('ui.selection_player')\n        st = load_settings()\n        self.lang = st.get('language','en-US')\n        # Steps: 0 Gender, 1 Race, 2 Class, 3 Sign, 4 Skills(2), 5 Name, 6 Summary\n        self.step = 0\n        self.sel_gender = 0\n        self.races = list(RACES.keys())\n        self.classes = list(CLASSES.keys())\n        self.sel_race = 0\n        self.sel_class = 0\n        self.sel_sign = 0\n        self.sel_skill_idx = 0\n        self.chosen_skills: list[str] = []\n        self.name = ''\n        self._anim_t = 0.0\n        self._anim_idx = 0\n\n    def handle(self, events):\n        for e in events:\n            if e.type == pygame.KEYDOWN:\n                if self.step in (0,1,2,3):\n                    if e.key in (pygame.K_LEFT, pygame.K_a):\n                        if self.step == 0: self.sel_gender = (self.sel_gender - 1) % len(GENDERS)\n                        elif self.step == 1: self.sel_race = (self.sel_race - 1) % len(self.races)\n                        elif self.step == 2: self.sel_class = (self.sel_class - 1) % len(self.classes)\n                        else: self.sel_sign = (self.sel_sign - 1) % len(self._signs())\n                    elif e.key in (pygame.K_RIGHT, pygame.K_d):\n                        if self.step == 0: self.sel_gender = (self.sel_gender + 1) % len(GENDERS)\n                        elif self.step == 1: self.sel_race = (self.sel_race + 1) % len(self.races)\n                        elif self.step == 2: self.sel_class = (self.sel_class + 1) % len(self.classes)\n                        else: self.sel_sign = (self.sel_sign + 1) % len(self._signs())\n                    elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                        self.step += 1\n                    elif e.key == pygame.K_ESCAPE:\n                        if self.step > 0: self.step -= 1\n                        else:\n                            from gameplay.scene_mainmenu import SceneMainMenu\n                            self.mgr.switch_to(SceneMainMenu(self.mgr))\n                elif self.step == 4:  # skills (use localized list consistently)\n                    skills = self._skills_localized()\n                    if e.key in (pygame.K_LEFT, pygame.K_a):\n                        self.sel_skill_idx = (self.sel_skill_idx - 1) % len(skills)\n                    elif e.key in (pygame.K_RIGHT, pygame.K_d):\n                        self.sel_skill_idx = (self.sel_skill_idx + 1) % len(skills)\n                    elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                        cur = skills[self.sel_skill_idx]\n                        if cur in self.chosen_skills:\n                            self.chosen_skills.remove(cur)\n                        elif len(self.chosen_skills) < 2:\n                            self.chosen_skills.append(cur)\n                        if len(self.chosen_skills) == 2:\n                            self.step += 1\n                    elif e.key == pygame.K_ESCAPE:\n                        self.step -= 1\n                elif self.step == 5:  # name\n                    if e.key == pygame.K_RETURN and self.name.strip(): self.step = 6\n                    elif e.key == pygame.K_BACKSPACE: self.name = self.name[:-1]\n                    elif e.key == pygame.K_ESCAPE: self.step = 4\n                    else:\n                        ch = e.unicode\n                        if ch and (ch.isalnum() or ch in ' _-') and len(self.name) < 16: self.name += ch\n                elif self.step == 6:\n                    if e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                        race = self.races[self.sel_race]\n                        clazz = self.classes[self.sel_class]\n                        stats = self._build_final_stats(race, clazz)\n                        profile = {\n                            'name': self.name.strip(),\n                            'gender': GENDERS[self.sel_gender],\n                            'race': race,\n                            'clazz': clazz,\n                            'sign': self._signs()[self.sel_sign],\n                            'skills': list(self.chosen_skills),\n                            'stats': stats,\n                        }\n                        self.on_complete(profile)\n                    elif e.key == pygame.K_ESCAPE:\n                        self.step = 5\n\n    def _signs(self):\n        return list(t('signs.list', self.lang))\n\n    def _skills_localized(self):\n        return list(t('skills.list', self.lang))\n\n    def _build_final_stats(self, race, clazz):\n        st = build_stats(race, clazz)\n        # Map localized sign -> canonical by aligned index using the en-US list from t()\n        signs_loc = self._signs()\n        en_signs = list(t('signs.list', 'en-US'))\n        try:\n            idx = self.sel_sign % len(en_signs)\n            canonical = en_signs[idx]\n        except Exception:\n            canonical = 'The Blade'\n        sb = SIGN_BONUS.get(canonical, {})\n        # attribute ups\n        for k in ('STR','DEX','INT','VIT','END','WIS'):\n            inc = sb.get(k, 0)\n            if inc:\n                setattr(st, k, getattr(st, k) + inc)\n        # skills bonuses (map localized -> canonical by index)\n        skills_loc = self._skills_localized()\n        for s in self.chosen_skills:\n            try:\n                idx = skills_loc.index(s)\n                canonical_s = SKILL_LIST[idx]\n            except Exception:\n                canonical_s = s\n            b = SKILL_BONUS.get(canonical_s, {})\n            for k, inc in b.items():\n                setattr(st, k, getattr(st, k) + inc)\n        # rebuild derived with percentages\n        st.HP = 30 + st.VIT * 8\n        st.MP = int((10 + st.INT * 8 + st.WIS * 4) * (1.0 + sb.get('MP%',0)))\n        st.STA = int((20 + st.END * 6) * (1.0 + sb.get('STA%',0)))\n        return st.__dict__\n\n    def update(self, dt):\n        self._anim_t += dt\n        if self._anim_t >= 0.20:\n            self._anim_t -= 0.20\n            self._anim_idx = (self._anim_idx + 1) % 4\n\n    def draw(self, screen):\n        if self.bg: blit_cover(screen, self.bg)\n        else: screen.fill((10,12,18))\n        w,h = SCREEN_SIZE\n        panel = pygame.Surface((int(w*0.80), int(h*0.70)), pygame.SRCALPHA)\n        panel.fill((0,0,0,120))\n        screen.blit(panel, (int(w*0.10), int(h*0.15)))\n        titles = t('char.titles', self.lang)\n        head = self.font.render(titles[self.step], True, (230,230,230))\n        screen.blit(head, head.get_rect(center=(w//2, int(h*0.22))))\n        if self.step == 0:\n            opt = self.font.render(GENDERS[self.sel_gender], True, (240,220,160))\n            screen.blit(opt, opt.get_rect(center=(w//2, int(h*0.45))))\n            hint = t('char.hint.nav', self.lang)\n            screen.blit(self.small.render(hint, True, (180,180,180)), (int(w*0.12), int(h*0.78)))\n        elif self.step == 1:\n            race = self.races[self.sel_race]\n            race_label = t(f'race.{race}.name', self.lang)\n            opt = self.font.render(race_label, True, (240,220,160))\n            screen.blit(opt, opt.get_rect(center=(w//2, int(h*0.40))))\n            desc = t(f'race.{race}.desc', self.lang)\n            screen.blit(self.small.render(desc, True, (210,210,210)), (int(w*0.12), int(h*0.50)))\n            hint = t('char.hint.nav', self.lang)\n            screen.blit(self.small.render(hint, True, (180,180,180)), (int(w*0.12), int(h*0.78)))\n        elif self.step == 2:\n            clazz = self.classes[self.sel_class]\n            label = t(f'class.{clazz}.name', self.lang)\n            opt = self.font.render(label, True, (240,220,160))\n            screen.blit(opt, opt.get_rect(center=(w//2, int(h*0.40))))\n            desc = t(f'class.{clazz}.desc', self.lang)\n            screen.blit(self.small.render(desc, True, (210,210,210)), (int(w*0.12), int(h*0.50)))\n            hint = t('char.hint.nav', self.lang)\n            screen.blit(self.small.render(hint, True, (180,180,180)), (int(w*0.12), int(h*0.78)))\n        elif self.step == 3:\n            signs = self._signs()\n            sign = signs[self.sel_sign]\n            opt = self.font.render(sign, True, (240,220,160))\n            screen.blit(opt, opt.get_rect(center=(w//2, int(h*0.40))))\n            # Map by index to canonical and translate description key properly\n            en_signs = list(t('signs.list', 'en-US'))\n            try:\n                canonical = en_signs[self.sel_sign % len(en_signs)]\n            except Exception:\n                canonical = 'The Blade'\n            desc = t('signs.desc.' + canonical, self.lang)\n            screen.blit(self.small.render(desc, True, (210,210,210)), (int(w*0.12), int(h*0.50)))\n            hint = t('char.hint.nav', self.lang)\n            screen.blit(self.small.render(hint, True, (180,180,180)), (int(w*0.12), int(h*0.78)))\n        elif self.step == 4:\n            skills = self._skills_localized()\n            cur = skills[self.sel_skill_idx]\n            msg = f\"{t('char.hint.skills', self.lang)}\"\n            screen.blit(self.small.render(msg, True, (180,180,180)), (int(w*0.12), int(h*0.78)))\n            # Show full list and mark selected\n            y = int(h*0.36)\n            list_text = '  '.join([('['+s+']') if s in self.chosen_skills else s for s in skills])\n            surf = self.small.render(list_text, True, (230,230,230))\n            screen.blit(surf, surf.get_rect(center=(w//2, y)))\n            cur_s = self.font.render(cur, True, (240,220,160))\n            screen.blit(cur_s, cur_s.get_rect(center=(w//2, int(h*0.46))))\n        elif self.step == 5:\n            box = pygame.Rect(0,0, max(360, w//3), 52); box.center = (w//2, int(h*0.48))\n            pygame.draw.rect(screen, (24,24,32), box, border_radius=6); pygame.draw.rect(screen, (90,90,120), box, 2, border_radius=6)\n            txt = self.font.render(self.name or '', True, (240,220,160))\n            screen.blit(txt, txt.get_rect(midleft=(box.left+12, box.centery)))\n            hint = t('char.hint.name', self.lang)\n            screen.blit(self.small.render(hint, True, (180,180,180)), (int(w*0.12), int(h*0.78)))\n        else:\n            race = self.races[self.sel_race]; clazz = self.classes[self.sel_class]\n            st = self._build_final_stats(race, clazz)\n            sign = self._signs()[self.sel_sign]\n            lines = [\n                f\"Name: {self.name}\",\n                f\"Gender: {GENDERS[self.sel_gender]}\",\n                f\"Race: {t(f'race.{race}.name', self.lang)}\",\n                f\"Class: {t(f'class.{clazz}.name', self.lang)}\",\n                f\"Sign: {sign}\",\n                f\"Skills: {', '.join(self.chosen_skills)}\",\n                f\"HP: {st['HP']} MP: {st['MP']} STA: {st['STA']}\",\n                f\"STR: {st['STR']} DEX: {st['DEX']} INT: {st['INT']}\",\n                f\"VIT: {st['VIT']} END: {st['END']} WIS: {st['WIS']}\",\n                t('char.hint.summary', self.lang)\n            ]\n            y = int(h*0.30)\n            for ln in lines:\n                surf = self.small.render(ln, True, (230,230,230)); screen.blit(surf, (int(w*0.12), y)); y += 28\n"
    },
    {
      "path": "gameplay\\combat.py",
      "loc": 60,
      "classes": [
        {
          "name": "Health",
          "start_line": 8,
          "end_line": 19,
          "methods": [
            {
              "name": "take",
              "args": [
                "self",
                "dmg"
              ],
              "decorators": [],
              "start_line": 12,
              "end_line": 15,
              "draw_suspect": false
            },
            {
              "name": "alive",
              "args": [
                "self"
              ],
              "decorators": [
                "property"
              ],
              "start_line": 18,
              "end_line": 19,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "compute_facing_from_iso_vel",
          "args": [
            "vel_r",
            "vel_c"
          ],
          "decorators": [],
          "start_line": 22,
          "end_line": 34,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "make_melee_hitbox",
          "args": [
            "attacker_rect",
            "facing",
            "reach_px",
            "width_px"
          ],
          "decorators": [],
          "start_line": 37,
          "end_line": 50,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw_hitbox_debug",
          "args": [
            "screen",
            "rect",
            "color"
          ],
          "decorators": [],
          "start_line": 53,
          "end_line": 59,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "take",
          "args": [
            "self",
            "dmg"
          ],
          "decorators": [],
          "start_line": 12,
          "end_line": 15,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "alive",
          "args": [
            "self"
          ],
          "decorators": [
            "property"
          ],
          "start_line": 18,
          "end_line": 19,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "dataclasses"
      ],
      "uses_pygame": true,
      "source_code": "# gameplay/combat.py — shared combat helpers (player & enemy)\nimport pygame\nfrom dataclasses import dataclass\n\nSTRIKE_FRAME_INDEX = 1  # attack frame that emits damage (0-based)\n\n@dataclass\nclass Health:\n    hp: int = 20\n    hp_max: int = 20\n\n    def take(self, dmg: int) -> int:\n        dmg = int(max(0, dmg))\n        self.hp = max(0, self.hp - dmg)\n        return dmg\n\n    @property\n    def alive(self) -> bool:\n        return self.hp > 0\n\n\ndef compute_facing_from_iso_vel(vel_r: float, vel_c: float) -> pygame.Vector2:\n    \"\"\"Converts iso grid (r,c) velocity to screen-space facing (dx,dy).\n    r decreases up-left, increases down-right; c decreases up-right, increases down-left.\n    We'll map to approximate screen pixel directions.\n    \"\"\"\n    # Convert grid velocity into approximate screen delta in pixels (not scaled by tile size here)\n    dx = (vel_c - vel_r) * 1.0\n    dy = (vel_c + vel_r) * 1.0\n    v = pygame.Vector2(dx, dy)\n    if v.length_squared() == 0:\n        return pygame.Vector2(1, 0)  # default facing right-ish\n    v = v.normalize()\n    return v\n\n\ndef make_melee_hitbox(attacker_rect: pygame.Rect, facing: pygame.Vector2,\n                       reach_px: int = 56, width_px: int = 50) -> pygame.Rect:\n    \"\"\"Simple axis-aligned rectangle projected in the facing direction from attacker's rect.\n    Facing is a normalized screen-space vector.\n    \"\"\"\n    fx, fy = facing.x, facing.y\n    # Project point from attacker center\n    cx, cy = attacker_rect.center\n    hx = int(cx + fx * reach_px)\n    hy = int(cy + fy * reach_px)\n    # Build a box centered at (hx,hy)\n    w = width_px\n    h = int(width_px * 0.8)\n    return pygame.Rect(hx - w//2, hy - h//2, w, h)\n\n\ndef draw_hitbox_debug(screen: pygame.Surface, rect: pygame.Rect, color=(255,80,80)):\n    if rect is None:\n        return\n    s = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)\n    s.fill((*color, 60))\n    screen.blit(s, (rect.x, rect.y))\n    pygame.draw.rect(screen, (*color, 220), rect, 2)\n"
    },
    {
      "path": "gameplay\\dialogue.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "gameplay\\enemies_iso.py",
      "loc": 80,
      "classes": [
        {
          "name": "EnemyIso",
          "start_line": 6,
          "end_line": 45,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "r",
                "c",
                "color"
              ],
              "decorators": [],
              "start_line": 7,
              "end_line": 19,
              "draw_suspect": false
            },
            {
              "name": "update_rect",
              "args": [
                "self",
                "ox",
                "oy"
              ],
              "decorators": [],
              "start_line": 21,
              "end_line": 24,
              "draw_suspect": false
            },
            {
              "name": "update_ai",
              "args": [
                "self",
                "dt",
                "target_rc"
              ],
              "decorators": [],
              "start_line": 26,
              "end_line": 45,
              "draw_suspect": false
            }
          ]
        },
        {
          "name": "EnemiesIso",
          "start_line": 47,
          "end_line": 79,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 48,
              "end_line": 53,
              "draw_suspect": false
            },
            {
              "name": "_spawn_from_pois",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 55,
              "end_line": 68,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt",
                "player_rc",
                "ox",
                "oy"
              ],
              "decorators": [],
              "start_line": 70,
              "end_line": 73,
              "draw_suspect": false
            },
            {
              "name": "draw_sorted",
              "args": [
                "self",
                "screen",
                "camera"
              ],
              "decorators": [],
              "start_line": 75,
              "end_line": 79,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "r",
            "c",
            "color"
          ],
          "decorators": [],
          "start_line": 7,
          "end_line": 19,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update_rect",
          "args": [
            "self",
            "ox",
            "oy"
          ],
          "decorators": [],
          "start_line": 21,
          "end_line": 24,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update_ai",
          "args": [
            "self",
            "dt",
            "target_rc"
          ],
          "decorators": [],
          "start_line": 26,
          "end_line": 45,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 48,
          "end_line": 53,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_spawn_from_pois",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 55,
          "end_line": 68,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt",
            "player_rc",
            "ox",
            "oy"
          ],
          "decorators": [],
          "start_line": 70,
          "end_line": 73,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw_sorted",
          "args": [
            "self",
            "screen",
            "camera"
          ],
          "decorators": [],
          "start_line": 75,
          "end_line": 79,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "random",
        "systems.iso_math",
        "core.config",
        "math"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame, random\nfrom systems.iso_math import grid_to_screen\nfrom core.config import TILE_W, TILE_H\n\nclass EnemyIso(pygame.sprite.Sprite):\n    def __init__(self, r, c, color=(170,80,60)):\n        super().__init__()\n        self.r = float(r)\n        self.c = float(c)\n        self.image = pygame.Surface((TILE_W, TILE_H*2), pygame.SRCALPHA)\n        # Simple placeholder humanoid\n        body = pygame.Surface((24, 36), pygame.SRCALPHA)\n        body.fill((*color, 255))\n        self.image.blit(body, (TILE_W//2 - 12, TILE_H))\n        self.rect = self.image.get_rect()\n        self.speed_tiles = 2.4  # tiles per second\n        self.vel_r = 0.0\n        self.vel_c = 0.0\n\n    def update_rect(self, ox, oy):\n        x, y = grid_to_screen(self.r, self.c)\n        x += ox; y += oy\n        self.rect.midbottom = (x + TILE_W//2, y + TILE_H)\n\n    def update_ai(self, dt, target_rc):\n        tr, tc = target_rc\n        dr = tr - self.r\n        dc = tc - self.c\n        d2 = dr*dr + dc*dc\n        if d2 < 900:  # within 30 tiles radius\n            import math\n            d = math.sqrt(d2)\n            if d > 0.001:\n                self.vel_r = (dr/d) * self.speed_tiles\n                self.vel_c = (dc/d) * self.speed_tiles\n            else:\n                self.vel_r = self.vel_c = 0.0\n        else:\n            # idle wander\n            if random.random() < 0.01:\n                self.vel_r = random.uniform(-0.3, 0.3)\n                self.vel_c = random.uniform(-0.3, 0.3)\n        self.r += self.vel_r * dt\n        self.c += self.vel_c * dt\n\nclass EnemiesIso:\n    def __init__(self, *, tilemap, pois: dict | None, rng_seed=2025):\n        self.tilemap = tilemap\n        self.pois = pois or {}\n        self.group = pygame.sprite.Group()\n        self.rng = random.Random(rng_seed)\n        self._spawn_from_pois()\n\n    def _spawn_from_pois(self):\n        # Spawn near caves and mountain\n        if 'cave_entrances' in self.pois:\n            for (r,c) in self.pois['cave_entrances']:\n                for i in range(2):\n                    rr = r + self.rng.randint(-3,3)\n                    cc = c + self.rng.randint(-3,3)\n                    self.group.add(EnemyIso(rr, cc, color=(170,80,60)))\n        if 'mountain_bbox' in self.pois:\n            top,left,h,w = self.pois['mountain_bbox']\n            for i in range(4):\n                rr = top + self.rng.randint(0, max(1,h-1))\n                cc = left + self.rng.randint(0, max(1,w-1))\n                self.group.add(EnemyIso(rr, cc, color=(100,60,140)))\n\n    def update(self, dt, player_rc, ox, oy):\n        for e in self.group.sprites():\n            e.update_ai(dt, player_rc)\n            e.update_rect(ox, oy)\n\n    def draw_sorted(self, screen, camera):\n        # sort by rect.bottom for pseudo-Z\n        sprites = sorted(self.group.sprites(), key=lambda s: s.rect.bottom)\n        for s in sprites:\n            screen.blit(s.image, camera.world_to_screen(s.rect.topleft))\n"
    },
    {
      "path": "gameplay\\game_scene.py",
      "loc": 40,
      "classes": [
        {
          "name": "GameScene",
          "start_line": 10,
          "end_line": 39,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 11,
              "end_line": 19,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 20,
              "end_line": 21,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 22,
              "end_line": 24,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 25,
              "end_line": 39,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 11,
          "end_line": 19,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 20,
          "end_line": 21,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 22,
          "end_line": 24,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 25,
          "end_line": 39,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "core.config",
        "core.camera",
        "core.tilemap",
        "systems.mapgen",
        "gameplay.player",
        "core.asset"
      ],
      "uses_pygame": true,
      "source_code": "# gameplay/game_scene.py — integrates camera, tilemap, player; shows missing assets overlay\nimport pygame\nfrom core.config import SCREEN_SIZE, TILE_SIZE\nfrom core.camera import Camera\nfrom core.tilemap import TileSet, TileMap\nfrom systems.mapgen import generate\nfrom gameplay.player import Player\nfrom core.asset import missing_assets\n\nclass GameScene:\n    def __init__(self):\n        self.w, self.h = SCREEN_SIZE\n        self.camera = Camera(self.w, self.h)\n        grid = generate(cols=64, rows=64)\n        self.tileset = TileSet()\n        self.tilemap = TileMap(grid, self.tileset)\n        # start near lake/grass boundary\n        self.player = Player(int(self.w*0.5), int(self.h*0.5))\n        self.font = pygame.font.SysFont('consolas', 18)\n    def handle(self, events):\n        pass\n    def update(self, dt):\n        self.player.update(dt)\n        self.camera.follow(self.player)\n    def draw(self, screen):\n        self.tilemap.draw(screen, self.camera)\n        screen.blit(self.player.image, self.camera.world_to_screen(self.player.rect.topleft))\n        # missing assets overlay\n        miss = missing_assets()\n        if miss:\n            y = 8\n            pane = pygame.Surface((self.w, 80), pygame.SRCALPHA)\n            pane.fill((0,0,0,160))\n            screen.blit(pane, (0,0))\n            screen.blit(self.font.render('ATENÇÃO: assets ausentes (usando placeholders):', True, (255,220,160)), (12,y)); y+=22\n            for p in miss[:2]:\n                screen.blit(self.font.render('- '+p, True, (220,220,220)), (12,y)); y+=20\n            if len(miss)>2:\n                screen.blit(self.font.render(f'... +{len(miss)-2} arquivos', True, (200,200,200)), (12,y))\n"
    },
    {
      "path": "gameplay\\inventory.py",
      "loc": 27,
      "classes": [
        {
          "name": "Inventory",
          "start_line": 4,
          "end_line": 26,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 5,
              "end_line": 7,
              "draw_suspect": false
            },
            {
              "name": "add",
              "args": [
                "self",
                "item",
                "qty"
              ],
              "decorators": [],
              "start_line": 8,
              "end_line": 8,
              "draw_suspect": false
            },
            {
              "name": "remove",
              "args": [
                "self",
                "item",
                "qty"
              ],
              "decorators": [],
              "start_line": 9,
              "end_line": 15,
              "draw_suspect": false
            },
            {
              "name": "add_gold",
              "args": [
                "self",
                "amount"
              ],
              "decorators": [],
              "start_line": 16,
              "end_line": 16,
              "draw_suspect": false
            },
            {
              "name": "spend_gold",
              "args": [
                "self",
                "amount"
              ],
              "decorators": [],
              "start_line": 17,
              "end_line": 21,
              "draw_suspect": false
            },
            {
              "name": "as_lines",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 22,
              "end_line": 26,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 5,
          "end_line": 7,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "add",
          "args": [
            "self",
            "item",
            "qty"
          ],
          "decorators": [],
          "start_line": 8,
          "end_line": 8,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "remove",
          "args": [
            "self",
            "item",
            "qty"
          ],
          "decorators": [],
          "start_line": 9,
          "end_line": 15,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "add_gold",
          "args": [
            "self",
            "amount"
          ],
          "decorators": [],
          "start_line": 16,
          "end_line": 16,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "spend_gold",
          "args": [
            "self",
            "amount"
          ],
          "decorators": [],
          "start_line": 17,
          "end_line": 21,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "as_lines",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "collections"
      ],
      "uses_pygame": false,
      "source_code": "\nfrom collections import Counter\n\nclass Inventory:\n    def __init__(self):\n        self.items = Counter()\n        self.gold = 0\n    def add(self, item: str, qty: int = 1): self.items[item] += qty\n    def remove(self, item: str, qty: int = 1) -> bool:\n        if self.items[item] >= qty:\n            self.items[item] -= qty\n            if self.items[item] <= 0:\n                del self.items[item]\n            return True\n        return False\n    def add_gold(self, amount: int): self.gold += amount\n    def spend_gold(self, amount: int) -> bool:\n        if self.gold >= amount:\n            self.gold -= amount\n            return True\n        return False\n    def as_lines(self) -> list[str]:\n        lines = [f\"Ouro: {self.gold}\"]\n        for k, v in self.items.items():\n            lines.append(f\"{k} x{v}\")\n        return lines\n"
    },
    {
      "path": "gameplay\\npc.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "gameplay\\player.py",
      "loc": 33,
      "classes": [
        {
          "name": "Player",
          "start_line": 6,
          "end_line": 32,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "x",
                "y"
              ],
              "decorators": [],
              "start_line": 7,
              "end_line": 20,
              "draw_suspect": true
            },
            {
              "name": "handle_input",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 21,
              "end_line": 28,
              "draw_suspect": true
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 29,
              "end_line": 32,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "x",
            "y"
          ],
          "decorators": [],
          "start_line": 7,
          "end_line": 20,
          "draw_suspect": true,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle_input",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 21,
          "end_line": 28,
          "draw_suspect": true,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 29,
          "end_line": 32,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "core.config",
        "core.asset"
      ],
      "uses_pygame": true,
      "source_code": "# gameplay/player.py — crisp 128x128; uses existing asset if present\nimport pygame\nfrom core.config import PLAYER_SIZE, PLAYER_SPEED\nfrom core.asset import load_scaled\n\nclass Player(pygame.sprite.Sprite):\n    def __init__(self, x, y):\n        super().__init__()\n        # Try preferred asset: assets/player/player_128.png; else scale player.png to 128; else crisp placeholder\n        img = load_scaled('player/player_128.png', (PLAYER_SIZE, PLAYER_SIZE), smooth=False)\n        if img is None:\n            img = load_scaled('player/player.png', (PLAYER_SIZE, PLAYER_SIZE), smooth=False)\n        if img is None:\n            img = pygame.Surface((PLAYER_SIZE, PLAYER_SIZE), pygame.SRCALPHA)\n            pygame.draw.rect(img, (60,140,220), (16,32,PLAYER_SIZE-32,PLAYER_SIZE-48), border_radius=12)\n            pygame.draw.circle(img, (230,210,180), (PLAYER_SIZE//2, 32), 24)\n        self.image = img\n        self.rect = self.image.get_rect(topleft=(x,y))\n        self.speed = float(PLAYER_SPEED)\n        self.vel = pygame.Vector2(0,0)\n    def handle_input(self):\n        k=pygame.key.get_pressed()\n        self.vel.update(0,0)\n        if k[pygame.K_UP] or k[pygame.K_w]: self.vel.y = -1\n        if k[pygame.K_DOWN] or k[pygame.K_s]: self.vel.y =  1\n        if k[pygame.K_LEFT] or k[pygame.K_a]: self.vel.x = -1\n        if k[pygame.K_RIGHT] or k[pygame.K_d]: self.vel.x =  1\n        if self.vel.length_squared()>0: self.vel = self.vel.normalize()\n    def update(self, dt):\n        self.handle_input()\n        self.rect.x += int(self.vel.x * self.speed * dt)\n        self.rect.y += int(self.vel.y * self.speed * dt)\n"
    },
    {
      "path": "gameplay\\player_iso.py",
      "loc": 118,
      "classes": [
        {
          "name": "Player",
          "start_line": 21,
          "end_line": 117,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "start_r",
                "start_c",
                "profile"
              ],
              "decorators": [],
              "start_line": 22,
              "end_line": 41,
              "draw_suspect": true
            },
            {
              "name": "update_rect",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 43,
              "end_line": 47,
              "draw_suspect": false
            },
            {
              "name": "_set_state",
              "args": [
                "self",
                "st"
              ],
              "decorators": [],
              "start_line": 49,
              "end_line": 53,
              "draw_suspect": true
            },
            {
              "name": "handle_input",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 55,
              "end_line": 80,
              "draw_suspect": false
            },
            {
              "name": "take_damage",
              "args": [
                "self",
                "dmg"
              ],
              "decorators": [],
              "start_line": 82,
              "end_line": 83,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 86,
              "end_line": 117,
              "draw_suspect": true
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "set_map_offset",
          "args": [
            "x",
            "y"
          ],
          "decorators": [],
          "start_line": 15,
          "end_line": 18,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "__init__",
          "args": [
            "self",
            "start_r",
            "start_c",
            "profile"
          ],
          "decorators": [],
          "start_line": 22,
          "end_line": 41,
          "draw_suspect": true,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update_rect",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 43,
          "end_line": 47,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_set_state",
          "args": [
            "self",
            "st"
          ],
          "decorators": [],
          "start_line": 49,
          "end_line": 53,
          "draw_suspect": true,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle_input",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 55,
          "end_line": 80,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "take_damage",
          "args": [
            "self",
            "dmg"
          ],
          "decorators": [],
          "start_line": 82,
          "end_line": 83,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 86,
          "end_line": 117,
          "draw_suspect": true,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "core.config",
        "systems.iso_math",
        "gameplay.actor_sprites",
        "gameplay.combat"
      ],
      "uses_pygame": true,
      "source_code": "# gameplay/player_iso.py — updated: shared sprites, attack hitbox, HP\nimport pygame\nfrom core.config import PLAYER_SIZE, TILE_W, TILE_H, PLAYER_SPEED_TILES\nfrom systems.iso_math import grid_to_screen\nfrom gameplay.actor_sprites import build_actor_sprites\nfrom gameplay.combat import Health, compute_facing_from_iso_vel, make_melee_hitbox, STRIKE_FRAME_INDEX\n\nANIM_FPS_WALK = 8\nANIM_FPS_RUN = 12\nATTACK_COOL = 0.35\nMAP_OFFSET_X = 0\nMAP_OFFSET_Y = 0\n\n\ndef set_map_offset(x: int, y: int):\n    global MAP_OFFSET_X, MAP_OFFSET_Y\n    MAP_OFFSET_X = int(x)\n    MAP_OFFSET_Y = int(y)\n\n\nclass Player(pygame.sprite.Sprite):\n    def __init__(self, start_r: int, start_c: int, profile: dict | None = None):\n        super().__init__()\n        self.r = float(start_r)\n        self.c = float(start_c)\n        self.base_speed = PLAYER_SPEED_TILES\n        self.vel_r = 0.0\n        self.vel_c = 0.0\n        self.anim = build_actor_sprites(profile, size=(PLAYER_SIZE, PLAYER_SIZE))\n        self.state = \"idle\"\n        self.anim_t = 0.0\n        self.anim_idx = 0\n        self.attack_t = 0.0\n        self.image = self.anim[\"idle\"][0]\n        self.rect = self.image.get_rect()\n        self.update_rect()\n        # Combat\n        self.health = Health(hp=24, hp_max=24)\n        self.damage = 6\n        self.last_hitbox: pygame.Rect | None = None\n        self.facing = pygame.Vector2(1, 0)\n\n    def update_rect(self):\n        sx, sy = grid_to_screen(self.r, self.c)\n        sx += MAP_OFFSET_X\n        sy += MAP_OFFSET_Y\n        self.rect.midbottom = (sx + TILE_W // 2, sy + TILE_H)\n\n    def _set_state(self, st: str):\n        if st != self.state:\n            self.state = st\n            self.anim_t = 0.0\n            self.anim_idx = 0\n\n    def handle_input(self, dt: float):\n        keys = pygame.key.get_pressed()\n        dr = dc = 0.0\n        if keys[pygame.K_UP] or keys[pygame.K_w]:\n            dr += -1; dc += -1\n        if keys[pygame.K_DOWN] or keys[pygame.K_s]:\n            dr += 1; dc += 1\n        if keys[pygame.K_LEFT] or keys[pygame.K_a]:\n            dr += 1; dc += -1\n        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:\n            dr += -1; dc += 1\n        speed = self.base_speed * (1.6 if keys[pygame.K_LSHIFT] else 1.0)\n        if dr != 0.0 or dc != 0.0:\n            mag = (dr*dr + dc*dc) ** 0.5\n            dr /= mag; dc /= mag\n            self.vel_r = dr * speed\n            self.vel_c = dc * speed\n            self._set_state(\"run\" if keys[pygame.K_LSHIFT] else \"walk\")\n        else:\n            self.vel_r = self.vel_c = 0.0\n            if self.attack_t <= 0:\n                self._set_state(\"idle\")\n        # Attack\n        if keys[pygame.K_j] and self.attack_t <= 0.0:\n            self.attack_t = ATTACK_COOL\n            self._set_state(\"attack\")\n\n    def take_damage(self, dmg: int):\n        self.health.take(dmg)\n        # TODO: hurt feedback/flash\n\n    def update(self, dt: float):\n        self.handle_input(dt)\n        self.r += self.vel_r * dt\n        self.c += self.vel_c * dt\n        self.update_rect()\n        # Facing from velocity (fallback keeps last)\n        v = compute_facing_from_iso_vel(self.vel_r, self.vel_c)\n        if v.length_squared() > 0:\n            self.facing = v\n        # Reset emitted hitbox by default\n        self.last_hitbox = None\n        # Animation & attack hitbox emission\n        if self.state == \"attack\":\n            self.attack_t -= dt\n            fps = 12\n            self.anim_t += dt\n            if self.anim_t >= 1.0 / fps:\n                self.anim_t -= 1.0 / fps\n                self.anim_idx = min(self.anim_idx + 1, len(self.anim[\"attack\"]) - 1)\n            # Emit one melee hitbox at strike frame\n            if self.anim_idx == STRIKE_FRAME_INDEX:\n                self.last_hitbox = make_melee_hitbox(self.rect, self.facing, reach_px=70, width_px=56)\n            if self.attack_t <= 0.0 and self.anim_idx >= len(self.anim[\"attack\"]) - 1:\n                self._set_state(\"walk\" if (self.vel_r or self.vel_c) else \"idle\")\n        else:\n            fps = ANIM_FPS_RUN if self.state == \"run\" else (ANIM_FPS_WALK if self.state == \"walk\" else 6)\n            frames = self.anim[self.state]\n            self.anim_t += dt\n            if self.anim_t >= 1.0 / fps:\n                self.anim_t -= 1.0 / fps\n                self.anim_idx = (self.anim_idx + 1) % len(frames)\n        self.image = self.anim[self.state][self.anim_idx]\n"
    },
    {
      "path": "gameplay\\player_sprites.py",
      "loc": 32,
      "classes": [],
      "functions": [
        {
          "name": "_make_frame",
          "args": [
            "color_body",
            "color_cape",
            "step",
            "size"
          ],
          "decorators": [],
          "start_line": 4,
          "end_line": 14,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "build_profile_sprites",
          "args": [
            "profile",
            "size"
          ],
          "decorators": [],
          "start_line": 26,
          "end_line": 31,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame"
      ],
      "uses_pygame": true,
      "source_code": "# gameplay/player_sprites.py — placeholder animado por classe\nimport pygame\n\ndef _make_frame(color_body=(60,140,255), color_cape=(200,180,60), step=0, size=(32,48)):\n    w,h = size\n    surf = pygame.Surface((w,h), pygame.SRCALPHA)\n    pygame.draw.rect(surf, color_body, (8,14,16,22), border_radius=4)\n    pygame.draw.circle(surf, (230,210,180), (w//2, 10), 8)\n    cape_y = 18 + (step%2)*1\n    pygame.draw.polygon(surf, color_cape, [(6,cape_y),(w-6,cape_y),(w-10,h-6),(10,h-6)])\n    leg_off = (step%2)*2\n    pygame.draw.rect(surf, (40,40,50), (10, 36+leg_off, 4, 10))\n    pygame.draw.rect(surf, (40,40,50), (18, 36+(2-leg_off), 4, 10))\n    return surf\n\nCLASS_COLORS = {\n    'Guerreiro': ((90,150,200),(180,60,50)),\n    'Mago': ((120,90,200),(50,180,220)),\n    'Ladino': ((90,120,90),(120,120,120)),\n    'Arqueiro': ((90,120,60),(120,180,90)),\n    'Assassino': ((80,80,80),(200,40,40)),\n    'Bardo': ((150,100,150),(220,180,80)),\n    'Paladino': ((200,200,220),(200,170,60)),\n}\n\ndef build_profile_sprites(profile: dict|None, size=(32,48)):\n    clazz = (profile or {}).get('clazz', 'Guerreiro')\n    body, cape = CLASS_COLORS.get(clazz, ((60,140,255),(200,180,60)))\n    walk = [_make_frame(body, cape, step=i, size=size) for i in range(4)]\n    idle = [walk[0]]\n    return {'idle': idle, 'walk': walk}\n"
    },
    {
      "path": "gameplay\\quests.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "gameplay\\scene_campaign.py",
      "loc": 78,
      "classes": [
        {
          "name": "SceneCampaign",
          "start_line": 9,
          "end_line": 77,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "mgr"
              ],
              "decorators": [],
              "start_line": 10,
              "end_line": 19,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 21,
              "end_line": 34,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 36,
              "end_line": 37,
              "draw_suspect": false
            },
            {
              "name": "_exec",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 39,
              "end_line": 52,
              "draw_suspect": false
            },
            {
              "name": "_start_game",
              "args": [
                "self",
                "profile"
              ],
              "decorators": [],
              "start_line": 54,
              "end_line": 56,
              "draw_suspect": false
            },
            {
              "name": "_start_loaded",
              "args": [
                "self",
                "data"
              ],
              "decorators": [],
              "start_line": 58,
              "end_line": 61,
              "draw_suspect": false
            },
            {
              "name": "_ensure_fx",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 63,
              "end_line": 68,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 70,
              "end_line": 77,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "mgr"
          ],
          "decorators": [],
          "start_line": 10,
          "end_line": 19,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 21,
          "end_line": 34,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 36,
          "end_line": 37,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_exec",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 39,
          "end_line": 52,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_start_game",
          "args": [
            "self",
            "profile"
          ],
          "decorators": [],
          "start_line": 54,
          "end_line": 56,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_start_loaded",
          "args": [
            "self",
            "data"
          ],
          "decorators": [],
          "start_line": 58,
          "end_line": 61,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_ensure_fx",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 63,
          "end_line": 68,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 70,
          "end_line": 77,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "core.ui_fx",
        "core.settings",
        "core.strings",
        "ui.theme",
        "ui.widgets",
        "gameplay.scene_game",
        "gameplay.scene_game",
        "gameplay.char_create",
        "gameplay.scene_save_slots",
        "gameplay.scene_save_slots",
        "gameplay.scene_mainmenu",
        "gameplay.scene_mainmenu"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame\nfrom core.ui_fx import make_vignette, make_grain, tint\nfrom core.settings import load_settings\nfrom core.strings import t\nfrom ui.theme import COLORS, SPACING, get_font\nfrom ui.widgets import RightMenuList\n\nclass SceneCampaign:\n    def __init__(self, mgr):\n        self.mgr = mgr\n        st = load_settings()\n        self.lang = st.get('language','en-US')\n        self.font = get_font(38)\n        self._fx_size = None\n        self.vignette = None\n        self.grain = None\n        self.menu = RightMenuList(self.font)\n        self.sel = 0\n\n    def handle(self, events):\n        for e in events:\n            if e.type == pygame.QUIT:\n                self.mgr.running = False\n            elif e.type == pygame.KEYDOWN:\n                if e.key in (pygame.K_UP, pygame.K_w):\n                    self.sel = (self.sel - 1) % 4\n                elif e.key in (pygame.K_DOWN, pygame.K_s):\n                    self.sel = (self.sel + 1) % 4\n                elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                    self._exec()\n                elif e.key == pygame.K_ESCAPE:\n                    from gameplay.scene_mainmenu import SceneMainMenu\n                    self.mgr.switch_to(SceneMainMenu(self.mgr))\n\n    def update(self, dt):\n        self.menu.update(dt)\n\n    def _exec(self):\n        # 0 New Game, 1 Load Game, 2 Delete Game, 3 Back\n        if self.sel == 0:\n            from gameplay.char_create import SceneCharCreate\n            self.mgr.switch_to(SceneCharCreate(self.mgr, on_complete=lambda profile: self._start_game(profile)))\n        elif self.sel == 1:\n            from gameplay.scene_save_slots import SceneSaveSlots\n            self.mgr.switch_to(SceneSaveSlots(self.mgr, mode='load', on_loaded=self._start_loaded, on_back=lambda: self.mgr.switch_to(self)))\n        elif self.sel == 2:\n            from gameplay.scene_save_slots import SceneSaveSlots\n            self.mgr.switch_to(SceneSaveSlots(self.mgr, mode='delete', on_back=lambda: self.mgr.switch_to(self)))\n        else:\n            from gameplay.scene_mainmenu import SceneMainMenu\n            self.mgr.switch_to(SceneMainMenu(self.mgr))\n\n    def _start_game(self, profile):\n        from gameplay.scene_game import SceneGame\n        self.mgr.switch_to(SceneGame(self.mgr, profile=profile))\n\n    def _start_loaded(self, data):\n        from gameplay.scene_game import SceneGame\n        profile = data.get('profile', {})\n        self.mgr.switch_to(SceneGame(self.mgr, profile=profile, loaded_state=data))\n\n    def _ensure_fx(self, screen):\n        size = screen.get_size()\n        if self._fx_size != size:\n            self._fx_size = size\n            self.vignette = make_vignette(size, strength=0.75)\n            self.grain = make_grain(size, intensity=22)\n\n    def draw(self, screen):\n        screen.fill(COLORS['bg'])\n        self._ensure_fx(screen)\n        tint(screen, color=(20, 28, 42), alpha=42)\n        if self.vignette: screen.blit(self.vignette, (0,0))\n        if self.grain: screen.blit(self.grain, (0,0))\n        options = t('campaign.options', self.lang)\n        self.menu.draw(screen, options, self.sel, x_frac=0.82, y_frac=0.32, gap=SPACING['menu_gap']-2)\n"
    },
    {
      "path": "gameplay\\scene_game.py",
      "loc": 218,
      "classes": [
        {
          "name": "SceneGame",
          "start_line": 28,
          "end_line": 217,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "mgr",
                "profile",
                "loaded_state"
              ],
              "decorators": [],
              "start_line": 29,
              "end_line": 81,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 83,
              "end_line": 102,
              "draw_suspect": false
            },
            {
              "name": "_build_save_data",
              "args": [
                "self",
                "with_extras"
              ],
              "decorators": [],
              "start_line": 104,
              "end_line": 118,
              "draw_suspect": false
            },
            {
              "name": "_save_quick",
              "args": [
                "self",
                "slot"
              ],
              "decorators": [],
              "start_line": 120,
              "end_line": 127,
              "draw_suspect": false
            },
            {
              "name": "_exec_pause",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 129,
              "end_line": 146,
              "draw_suspect": false
            },
            {
              "name": "_location_hint",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 148,
              "end_line": 166,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 168,
              "end_line": 192,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 194,
              "end_line": 217,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "mgr",
            "profile",
            "loaded_state"
          ],
          "decorators": [],
          "start_line": 29,
          "end_line": 81,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 83,
          "end_line": 102,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_build_save_data",
          "args": [
            "self",
            "with_extras"
          ],
          "decorators": [],
          "start_line": 104,
          "end_line": 118,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_save_quick",
          "args": [
            "self",
            "slot"
          ],
          "decorators": [],
          "start_line": 120,
          "end_line": 127,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_exec_pause",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 129,
          "end_line": 146,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_location_hint",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 148,
          "end_line": 166,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 168,
          "end_line": 192,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 194,
          "end_line": 217,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "json",
        "typing",
        "core.config",
        "core.tilemap_iso",
        "gameplay.player_iso",
        "systems.iso_math",
        "gameplay.inventory",
        "core.asset",
        "core.settings",
        "core.strings",
        "ui.hud",
        "gameplay.enemies_iso",
        "gameplay.combat",
        "core.camera_v2",
        "systems.mapgen_iso",
        "core.camera",
        "systems.mapgen_iso",
        "core.config",
        "gameplay.scene_save_slots",
        "gameplay.scene_mainmenu"
      ],
      "uses_pygame": true,
      "source_code": "# gameplay/scene_game.py — jogo isométrico com câmera lookahead, hitbox e save slots (3)\nimport pygame, json\nfrom typing import Optional\nfrom core.config import SCREEN_SIZE, TILE_W, TILE_H\nfrom core.tilemap_iso import IsoTileSet, IsoMap\nfrom gameplay.player_iso import Player, set_map_offset\nfrom systems.iso_math import grid_to_screen\nfrom gameplay.inventory import Inventory\ntry:\n    from core.camera_v2 import CameraV2 as CameraImpl\n    _CAMERA_MODE = \"v2\"\nexcept Exception:\n    from core.camera import Camera as CameraImpl\n    _CAMERA_MODE = \"legacy\"\ntry:\n    from systems.mapgen_iso import generate_world as generate_iso_world\n    _WORLD_GEN = \"world\"\nexcept Exception:\n    from systems.mapgen_iso import generate as generate_iso_world\n    _WORLD_GEN = \"classic\"\nfrom core.asset import missing_assets\nfrom core.settings import load_settings\nfrom core.strings import t\nfrom ui.hud import draw_hud\nfrom gameplay.enemies_iso import EnemiesIso\nfrom gameplay.combat import draw_hitbox_debug\n\nclass SceneGame:\n    def __init__(self, mgr, profile: Optional[dict] = None, loaded_state: Optional[dict] = None):\n        self.mgr = mgr\n        self.profile = profile or {}\n        self.screen_w, self.screen_h = SCREEN_SIZE\n\n        if loaded_state and \"map\" in loaded_state:\n            data = loaded_state[\"map\"]\n            self.layers = data[\"layers\"]\n            start_r, start_c = loaded_state.get(\"player_rc\", (data[\"player_start\"][0], data[\"player_start\"][1]))\n            self.pois = loaded_state.get('pois', {})\n            self._play_time = float(loaded_state.get('play_time', 0.0))\n        else:\n            if _WORLD_GEN == \"world\":\n                data = generate_iso_world(cols=128, rows=128, mountain_frac=0.5, seed=2025)\n            else:\n                data = generate_iso_world(cols=64, rows=64)\n            self.layers = data[\"layers\"]\n            start_r, start_c = data[\"player_start\"]\n            self.pois = data.get(\"pois\", {})\n            self._play_time = 0.0\n\n        self.tileset = IsoTileSet()\n        self.tilemap = IsoMap(self.layers, self.tileset)\n        self.player = Player(start_r, start_c, profile=self.profile)\n        set_map_offset(self.tilemap.offset_x, self.tilemap.offset_y)\n        w, h = self.tilemap.world_bounds()\n        self.camera = CameraImpl(self.screen_w, self.screen_h, w, h)\n        if hasattr(self.camera, \"set_profile\"):\n            self.camera.set_profile(zoom=1.25)\n        px, py = grid_to_screen(self.player.r, self.player.c)\n        px += self.tilemap.offset_x; py += self.tilemap.offset_y\n        if hasattr(self.camera, \"center_on\"):\n            self.camera.center_on((px + TILE_W // 2, py + TILE_H // 2))\n\n        self.font = pygame.font.SysFont(\"consolas\", 18)\n        self.inv = Inventory()\n        if loaded_state and \"inventory\" in loaded_state:\n            self.inv.gold = loaded_state[\"inventory\"].get(\"gold\", 0)\n            for k, v in loaded_state[\"inventory\"].get(\"items\", {}).items():\n                self.inv.items[k] = v\n\n        st = self.profile.get('stats', {}) or {}\n        self.vitals_max = {'HP': st.get('HP', 60), 'MP': st.get('MP', 30), 'STA': st.get('STA', 30)}\n        self.vitals = dict(self.vitals_max)\n\n        self.paused = False\n        self.st = load_settings()\n        self.lang = self.st.get('language','en-US')\n        self.pause_tabs = list(t('pause.tabs', self.lang))\n        self.quest_hint = None\n        self._show_inv = False\n\n        self.enemies = EnemiesIso(tilemap=self.tilemap, pois=self.pois)\n\n    def handle(self, events):\n        for e in events:\n            if e.type == pygame.QUIT:\n                self.mgr.running = False\n            elif e.type == pygame.KEYDOWN:\n                if e.key == pygame.K_ESCAPE:\n                    self.paused = not self.paused\n                    return\n            if self.paused:\n                if e.type == pygame.KEYDOWN:\n                    if e.key in (pygame.K_UP, pygame.K_w):\n                        idx = getattr(self, 'pause_sel', 0)\n                        setattr(self, 'pause_sel', (idx - 1) % len(self.pause_tabs))\n                    elif e.key in (pygame.K_DOWN, pygame.K_s):\n                        idx = getattr(self, 'pause_sel', 0)\n                        setattr(self, 'pause_sel', (idx + 1) % len(self.pause_tabs))\n                    elif e.key in (pygame.K_1, pygame.K_2, pygame.K_3):\n                        self._save_quick({pygame.K_1:1, pygame.K_2:2, pygame.K_3:3}[e.key])\n                    elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                        self._exec_pause()\n\n    def _build_save_data(self, with_extras: bool=False) -> dict:\n        loc = self._location_hint()\n        data = {\n            \"profile\": self.profile,\n            \"inventory\": {\"gold\": self.inv.gold, \"items\": dict(self.inv.items)},\n            \"player_rc\": (self.player.r, self.player.c),\n            \"map\": {\"layers\": self.layers, \"player_start\": (int(self.player.r), int(self.player.c))},\n        }\n        if with_extras:\n            data.update({\n                \"play_time\": int(self._play_time),\n                \"location\": loc,\n                \"pois\": self.pois,\n            })\n        return data\n\n    def _save_quick(self, slot:int):\n        from core.config import SAVES_DIR\n        path = SAVES_DIR / f\"slot{int(slot)}.json\"\n        data = self._build_save_data(with_extras=True)\n        try:\n            path.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding='utf-8')\n        except Exception:\n            pass\n\n    def _exec_pause(self):\n        idx = getattr(self, 'pause_sel', 0)\n        cur = self.pause_tabs[idx]\n        if cur == t('pause.tabs', self.lang)[0]:\n            self.paused = False\n            return\n        save_label = t('pause.tabs', self.lang)[3] if len(t('pause.tabs', self.lang))>3 else 'Save'\n        if cur == save_label:\n            from gameplay.scene_save_slots import SceneSaveSlots\n            self.mgr.switch_to(SceneSaveSlots(self.mgr, mode='save',\n                on_saved=lambda info: self.mgr.switch_to(self),\n                on_back=lambda: self.mgr.switch_to(self)))\n            return\n        exit_label = t('pause.tabs', self.lang)[4] if len(t('pause.tabs', self.lang))>4 else 'Exit'\n        if cur == exit_label:\n            from gameplay.scene_mainmenu import SceneMainMenu\n            self.mgr.switch_to(SceneMainMenu(self.mgr))\n            return\n\n    def _location_hint(self) -> str:\n        r, c = int(self.player.r), int(self.player.c)\n        if isinstance(self.pois.get('village_bbox'), (list, tuple)) and len(self.pois['village_bbox'])>=4:\n            top,left,h,w = self.pois['village_bbox']\n            if top <= r <= top+h and left <= c <= left+w:\n                return t('poi.village', self.lang)\n        caves = self.pois.get('cave_entrances') or []\n        for (rr,cc) in caves:\n            if (r-rr)**2 + (c-cc)**2 <= 25:\n                return t('poi.cave', self.lang)\n        if 'lake_bbox' in self.pois:\n            top,left,h,w = self.pois['lake_bbox']\n            if top <= r <= top+h and left <= c <= left+w:\n                return t('poi.lake', self.lang)\n        if 'mountain_bbox' in self.pois:\n            top,left,h,w = self.pois['mountain_bbox']\n            if top <= r <= top+h and left <= c <= left+w:\n                return t('poi.peak', self.lang)\n        return '—'\n\n    def update(self, dt: float):\n        if not self.paused:\n            self._play_time += float(dt)\n        self.player.update(dt)\n        px, py = grid_to_screen(self.player.r, self.player.c)\n        px += self.tilemap.offset_x; py += self.tilemap.offset_y\n        focus = (px + TILE_W // 2, py + TILE_H // 2)\n        vx_px = (self.player.vel_c - self.player.vel_r) * (TILE_W / 2.0)\n        vy_px = (self.player.vel_c + self.player.vel_r) * (TILE_H / 2.0)\n        if hasattr(self.camera, 'update'):\n            self.camera.update(dt, focus_px=focus, vel_px=(vx_px, vy_px))\n        elif hasattr(self.camera, 'follow'):\n            fake = pygame.Rect(focus[0], focus[1], 1, 1)\n            self.camera.follow(fake)\n        self.enemies.update(dt, (self.player.r, self.player.c), self.tilemap.offset_x, self.tilemap.offset_y)\n        if self.player.last_hitbox:\n            for enemy in list(self.enemies.group.sprites()):\n                if self.player.last_hitbox.colliderect(enemy.rect):\n                    self.enemies.group.remove(enemy)\n                    try:\n                        self.inv.add_gold(1)\n                    except Exception:\n                        pass\n                    if hasattr(self.camera, 'apply_shake'):\n                        self.camera.apply_shake(6.0)\n\n    def draw(self, screen: pygame.Surface):\n        self.tilemap.draw(screen, self.camera)\n        screen.blit(self.player.image, self.camera.world_to_screen(self.player.rect.topleft))\n        self.enemies.draw_sorted(screen, self.camera)\n        if self.player.last_hitbox:\n            hr = self.player.last_hitbox.copy()\n            hr.topleft = self.camera.world_to_screen(hr.topleft)\n            draw_hitbox_debug(screen, hr)\n        miss = missing_assets()\n        if miss and self.st.get('show_missing', False):\n            y = 8\n            pane = pygame.Surface((self.screen_w, 84), pygame.SRCALPHA)\n            pane.fill((0,0,0,160))\n            screen.blit(pane, (0,0))\n            screen.blit(self.font.render(t('debug.missing', self.lang), True, (255,220,160)), (12, y)); y += 22\n            for p in miss[:2]:\n                screen.blit(self.font.render('- ' + p, True, (220,220,220)), (12, y)); y += 20\n            if len(miss) > 2:\n                more = f\"... +{len(miss)-2}\"\n                screen.blit(self.font.render(more, True, (200,200,200)), (12, y))\n        try:\n            draw_hud(screen, self)\n        except Exception:\n            pass\n"
    },
    {
      "path": "gameplay\\scene_game__handle_only.py",
      "loc": 16,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "    def handle(self, events):\n        for e in events:\n            if e.type == pygame.KEYDOWN:\n                # ESC sempre alterna pausa\n                if e.key == pygame.K_ESCAPE:\n                    self.paused = not self.paused\n                    return\n                # Se estiver pausado, navega no menu de pausa\n                if self.paused:\n                    if e.key in (pygame.K_UP, pygame.K_w):\n                        self.pause_sel = (self.pause_sel - 1) % len(self.pause_tabs)\n                    elif e.key in (pygame.K_DOWN, pygame.K_s):\n                        self.pause_sel = (self.pause_sel + 1) % len(self.pause_tabs)\n                    elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                        self._exec_pause()\n"
    },
    {
      "path": "gameplay\\scene_mainmenu.py",
      "loc": 91,
      "classes": [
        {
          "name": "SceneMainMenu",
          "start_line": 12,
          "end_line": 90,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "mgr"
              ],
              "decorators": [],
              "start_line": 13,
              "end_line": 25,
              "draw_suspect": false
            },
            {
              "name": "_build_options",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 27,
              "end_line": 31,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 33,
              "end_line": 43,
              "draw_suspect": false
            },
            {
              "name": "_exec",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 45,
              "end_line": 63,
              "draw_suspect": false
            },
            {
              "name": "_ensure_fx",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 65,
              "end_line": 70,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 72,
              "end_line": 79,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 81,
              "end_line": 90,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "mgr"
          ],
          "decorators": [],
          "start_line": 13,
          "end_line": 25,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_build_options",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 27,
          "end_line": 31,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 33,
          "end_line": 43,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_exec",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 45,
          "end_line": 63,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_ensure_fx",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 65,
          "end_line": 70,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 72,
          "end_line": 79,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 81,
          "end_line": 90,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "math",
        "core.asset",
        "core.ui_fx",
        "core.settings",
        "core.strings",
        "ui.theme",
        "ui.widgets",
        "systems.save_load",
        "gameplay.scene_campaign",
        "gameplay.scene_settings",
        "gameplay.scene_game"
      ],
      "uses_pygame": true,
      "source_code": "\n# gameplay/scene_mainmenu.py — Main Menu Skyrim-like with i18n and dynamic \"Continue\"\nimport pygame, math\nfrom core.asset import load_image_strict\nfrom core.ui_fx import blit_fit, make_vignette, make_grain, tint\nfrom core.settings import load_settings\nfrom core.strings import t\nfrom ui.theme import COLORS, SPACING, get_font\nfrom ui.widgets import RightMenuList\nfrom systems.save_load import has_save_any, list_saves, load_game\n\nclass SceneMainMenu:\n    def __init__(self, mgr):\n        self.mgr = mgr\n        st = load_settings()\n        self.lang = st.get('language','en-US')\n        self.bg = load_image_strict('ui/main_menu.png') or load_image_strict('ui/dragons_bg.png')\n        self.font = get_font(40)\n        self._fx_size = None\n        self.vignette = None\n        self.grain = None\n        self.options = self._build_options()\n        self.sel = 0\n        self._t = 0.0\n        self.menu = RightMenuList(self.font)\n\n    def _build_options(self):\n        opts = list(t('main.options', self.lang))\n        if has_save_any():\n            opts = [t('main.continue', self.lang)] + opts\n        return opts\n\n    def handle(self, events):\n        for e in events:\n            if e.type == pygame.KEYDOWN:\n                if e.key in (pygame.K_UP, pygame.K_w):\n                    self.sel = (self.sel - 1) % len(self.options)\n                elif e.key in (pygame.K_DOWN, pygame.K_s):\n                    self.sel = (self.sel + 1) % len(self.options)\n                elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                    self._exec()\n            elif e.type == pygame.QUIT:\n                self.mgr.running = False\n\n    def _exec(self):\n        cur = (self.options[self.sel] or '').lower()\n        if cur == t('main.continue', self.lang).lower():\n            saves = list_saves()\n            if saves:\n                data = load_game(saves[0])\n                if data:\n                    from gameplay.scene_game import SceneGame\n                    profile = data.get('profile', {})\n                    self.mgr.switch_to(SceneGame(self.mgr, profile=profile, loaded_state=data))\n                    return\n        if cur.startswith(t('main.options', self.lang)[0].lower()):\n            from gameplay.scene_campaign import SceneCampaign\n            self.mgr.switch_to(SceneCampaign(self.mgr))\n        elif cur.startswith(t('main.options', self.lang)[1].lower()):\n            from gameplay.scene_settings import SceneSettings\n            self.mgr.switch_to(SceneSettings(self.mgr, on_back=lambda: self.mgr.switch_to(self)))\n        else:\n            self.mgr.running = False\n\n    def _ensure_fx(self, screen):\n        size = screen.get_size()\n        if self._fx_size != size:\n            self._fx_size = size\n            self.vignette = make_vignette(size, strength=0.75)\n            self.grain = make_grain(size, intensity=24)\n\n    def update(self, dt):\n        self._t += dt\n        self.menu.update(dt)\n        # Hot-reload language when changed in settings\n        st = load_settings(); new_lang = st.get('language','en-US')\n        if new_lang != self.lang:\n            self.lang = new_lang\n            self.options = self._build_options()\n\n    def draw(self, screen):\n        if self.bg:\n            blit_fit(screen, self.bg)\n        else:\n            screen.fill(COLORS['bg'])\n        self._ensure_fx(screen)\n        tint(screen, color=(20,28,42), alpha=38)\n        if self.vignette: screen.blit(self.vignette, (0,0))\n        if self.grain: screen.blit(self.grain, (0,0))\n        self.menu.draw(screen, self.options, self.sel, x_frac=0.82, y_frac=0.35, gap=SPACING['menu_gap'])\n"
    },
    {
      "path": "gameplay\\scene_save_slots.py",
      "loc": 210,
      "classes": [
        {
          "name": "SceneSaveSlots",
          "start_line": 43,
          "end_line": 209,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "mgr",
                "mode",
                "on_loaded",
                "on_saved",
                "on_back"
              ],
              "decorators": [],
              "start_line": 44,
              "end_line": 57,
              "draw_suspect": false
            },
            {
              "name": "_load_slots_meta",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 59,
              "end_line": 95,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 97,
              "end_line": 110,
              "draw_suspect": false
            },
            {
              "name": "_confirm_action",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 112,
              "end_line": 136,
              "draw_suspect": false
            },
            {
              "name": "_avatar",
              "args": [
                "self",
                "idx"
              ],
              "decorators": [],
              "start_line": 138,
              "end_line": 152,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 154,
              "end_line": 209,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "draw_hover_arrow",
          "args": [
            "screen",
            "center"
          ],
          "decorators": [],
          "start_line": 19,
          "end_line": 41,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "__init__",
          "args": [
            "self",
            "mgr",
            "mode",
            "on_loaded",
            "on_saved",
            "on_back"
          ],
          "decorators": [],
          "start_line": 44,
          "end_line": 57,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_load_slots_meta",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 59,
          "end_line": 95,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 97,
          "end_line": 110,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_confirm_action",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 112,
          "end_line": 136,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_avatar",
          "args": [
            "self",
            "idx"
          ],
          "decorators": [],
          "start_line": 138,
          "end_line": 152,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 154,
          "end_line": 209,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        },
        {
          "name": "get_font",
          "args": [
            "size"
          ],
          "decorators": [],
          "start_line": 13,
          "end_line": 14,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "os",
        "json",
        "time",
        "math",
        "pygame",
        "core.config",
        "core.strings",
        "core.settings",
        "gameplay.actor_sprites",
        "ui.theme",
        "gameplay.scene_game"
      ],
      "uses_pygame": true,
      "source_code": "\n# gameplay/scene_save_slots.py — Menu de 3 Save Slots (Skyrim-like) + hover arrow visual\nimport os, json, time, math\nimport pygame\nfrom core.config import SAVES_DIR, SCREEN_SIZE\nfrom core.strings import t\nfrom core.settings import load_settings\nfrom gameplay.actor_sprites import build_actor_sprites\n\ntry:\n    from ui.theme import get_font\nexcept Exception:\n    def get_font(size):\n        return pygame.font.SysFont('georgia', size)\n\nSLOT_FILES = [SAVES_DIR / 'slot1.json', SAVES_DIR / 'slot2.json', SAVES_DIR / 'slot3.json']\n\n# --- Visual helper: minimal hover arrow (tipo Skyrim), sem tocar na lógica ---\ndef draw_hover_arrow(screen: pygame.Surface, center: tuple, *, size: int = 14,\n                     color=(240,220,160), pulse=True):\n    \"\"\"Desenha um pequeno cursor em forma de seta (>) com leve brilho/pulso.\n    Somente visual (sem alterar navegação/estados). \"\"\"\n    cx, cy = center\n    s = float(size)\n    if pulse:\n        t = pygame.time.get_ticks() * 0.001\n        s *= (1.0 + 0.06*math.sin(t*6.0))\n    s1 = int(s)\n    s2 = int(s*0.6)\n    # Triângulo apontando para a direita\n    pts = [(cx, cy), (cx - s1, cy - s2), (cx - s1, cy + s2)]\n    # Glow leve\n    glow = pygame.Surface((int(s1*2), int(s1*2)), pygame.SRCALPHA)\n    gx, gy = int(s1), int(s1)\n    off_pts = [(p[0]-cx+gx, p[1]-cy+gy) for p in pts]\n    for _, a in ((2,70),(1,110)):\n        pygame.draw.polygon(glow, (*color, a), off_pts)\n        screen.blit(glow, (cx-gx, cy-gy), special_flags=pygame.BLEND_ADD)\n    # Corpo da seta\n    pygame.draw.polygon(screen, color, pts)\n    pygame.draw.polygon(screen, (20,20,28), pts, 1)\n\nclass SceneSaveSlots:\n    def __init__(self, mgr, mode='load', on_loaded=None, on_saved=None, on_back=None):\n        self.mgr = mgr\n        self.mode = mode  # 'load' | 'save' | 'delete'\n        self.on_loaded = on_loaded\n        self.on_saved = on_saved\n        self.on_back = on_back\n        st = load_settings()\n        self.lang = st.get('language','en-US')\n        self.font_big = get_font(38)\n        self.font = get_font(24)\n        self.small = get_font(18)\n        self.sel = 0\n        self.preview_cache = [None, None, None]  # surfaces do avatar\n        self._load_slots_meta()\n\n    def _load_slots_meta(self):\n        self.slots = []\n        for path in SLOT_FILES:\n            if path.exists():\n                try:\n                    data = json.loads(path.read_text(encoding='utf-8'))\n                except Exception:\n                    data = None\n                if data:\n                    profile = data.get('profile', {})\n                    name = profile.get('name', '—')\n                    clazz = profile.get('clazz', 'Guerreiro')\n                    race = profile.get('race','Humano')\n                    clazz_label = t(f'class.{clazz}.name', self.lang)\n                    play_s = int(data.get('play_time', 0))\n                    h, m = play_s//3600, (play_s%3600)//60\n                    ptime = (f\"{h}h {m}m\" if h>0 else f\"{m}m\") if play_s>0 else '—'\n                    loc = data.get('location','—')\n                    ts = time.localtime(path.stat().st_mtime)\n                    when = time.strftime('%Y-%m-%d %H:%M', ts)\n                    self.slots.append({\n                        'exists': True,\n                        'file': path,\n                        'profile': profile,\n                        'name': name,\n                        'clazz': clazz,\n                        'race': race,\n                        'clazz_label': clazz_label,\n                        'play_time_str': ptime,\n                        'location': loc,\n                        'when': when,\n                        'data': data,\n                    })\n                else:\n                    self.slots.append({'exists': False, 'file': path})\n            else:\n                self.slots.append({'exists': False, 'file': path})\n\n    def handle(self, events):\n        for e in events:\n            if e.type == pygame.QUIT:\n                self.mgr.running = False\n            elif e.type == pygame.KEYDOWN:\n                if e.key in (pygame.K_UP, pygame.K_w):\n                    self.sel = (self.sel - 1) % 3\n                elif e.key in (pygame.K_DOWN, pygame.K_s):\n                    self.sel = (self.sel + 1) % 3\n                elif e.key in (pygame.K_ESCAPE,):\n                    if self.on_back:\n                        self.on_back()\n                elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                    self._confirm_action()\n\n    def _confirm_action(self):\n        slot = self.slots[self.sel]\n        path = slot['file']\n        # Ações por modo\n        if self.mode == 'load':\n            if slot.get('exists') and self.on_loaded:\n                self.on_loaded(slot['data'])\n        elif self.mode == 'save':\n            try:\n                from gameplay.scene_game import SceneGame\n                if isinstance(self.mgr.current_scene, SceneGame):\n                    data = self.mgr.current_scene._build_save_data(with_extras=True)\n                    path.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding='utf-8')\n                    if self.on_saved:\n                        self.on_saved({'slot': self.sel+1, 'path': str(path)})\n                    self._load_slots_meta()\n            except Exception:\n                pass\n        else:  # delete\n            if slot.get('exists'):\n                try:\n                    os.remove(path)\n                    self._load_slots_meta()\n                except Exception:\n                    pass\n\n    def _avatar(self, idx):\n        if self.preview_cache[idx] is not None:\n            return self.preview_cache[idx]\n        slot = self.slots[idx]\n        surf = pygame.Surface((128,128), pygame.SRCALPHA)\n        if slot.get('exists'):\n            try:\n                anim = build_actor_sprites(slot['profile'], size=(128,128))\n                surf.blit(anim['idle'][0], (0,0))\n            except Exception:\n                pygame.draw.rect(surf, (80,120,180), (16,24,96,96), border_radius=12)\n        else:\n            pygame.draw.rect(surf, (60,60,70), (16,24,96,96), border_radius=12)\n        self.preview_cache[idx] = surf\n        return surf\n\n    def draw(self, screen: pygame.Surface):\n        w,h = SCREEN_SIZE\n        screen.fill((12,14,20))\n        veil = pygame.Surface((w,h), pygame.SRCALPHA)\n        veil.fill((0,0,0,120))\n        screen.blit(veil, (0,0))\n\n        title_key = {'load':'saves.title.load','save':'saves.title.save','delete':'saves.title.delete'}.get(self.mode,'saves.title.load')\n        head = self.font_big.render(t(title_key, self.lang), True, (230,230,230))\n        screen.blit(head, head.get_rect(topleft=(int(w*0.10), int(h*0.12))))\n\n        hint = self.small.render(t('saves.hint', self.lang), True, (180,180,180))\n        screen.blit(hint, (int(w*0.10), int(h*0.86)))\n\n        right_x = int(w * 0.84)\n        card_w = int(w * 0.62)\n        card_h = int(h * 0.18)\n        gap = int(h * 0.04)\n        top = int(h * 0.24)\n\n        for i in range(3):\n            y = top + i*(card_h + gap)\n            rect = pygame.Rect(right_x - card_w, y, card_w, card_h)\n            pygame.draw.rect(screen, (18,20,28), rect, border_radius=8)\n            pygame.draw.rect(screen, (70,80,100) if i==self.sel else (40,48,64), rect, 2, border_radius=8)\n\n            slot = self.slots[i]\n            label = f\"{t('saves.slot', self.lang)} {i+1}\"\n            lbl = self.font.render(label, True, (200,200,215))\n            screen.blit(lbl, (rect.x + 14, rect.y + 12))\n\n            av = self._avatar(i)\n            screen.blit(av, (rect.x + 16, rect.y + 34))\n\n            tx = rect.x + 16 + 128 + 16\n            ty = rect.y + 36\n            if slot.get('exists'):\n                name = slot['name']\n                clazz = slot['clazz_label']\n                loc = slot['location']\n                ptime = slot['play_time_str']\n                when = slot['when']\n                lines = [f\"{name} — {clazz}\", f\"Play: {ptime}\", f\"Loc: {loc}\", f\"{when}\"]\n                col = (230,230,230)\n            else:\n                lines = [t('saves.available', self.lang), t('saves.empty', self.lang)]\n                col = (190,190,200)\n            for ln in lines:\n                s = self.font.render(ln, True, col)\n                screen.blit(s, (tx, ty)); ty += 30\n\n            # Cursor seta (apenas no selecionado)\n            if i == self.sel:\n                cx = rect.x - 24\n                cy = rect.centery\n                draw_hover_arrow(screen, (cx, cy), size=16, color=(240,220,160), pulse=True)\n"
    },
    {
      "path": "gameplay\\scene_settings.py",
      "loc": 192,
      "classes": [
        {
          "name": "SceneSettings",
          "start_line": 10,
          "end_line": 191,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "mgr",
                "on_back"
              ],
              "decorators": [],
              "start_line": 11,
              "end_line": 26,
              "draw_suspect": false
            },
            {
              "name": "_apply_and_save",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 28,
              "end_line": 31,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 33,
              "end_line": 50,
              "draw_suspect": false
            },
            {
              "name": "_enter_main",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 52,
              "end_line": 91,
              "draw_suspect": false
            },
            {
              "name": "_handle_submenu",
              "args": [
                "self",
                "e"
              ],
              "decorators": [],
              "start_line": 93,
              "end_line": 134,
              "draw_suspect": false
            },
            {
              "name": "_go_back",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 136,
              "end_line": 137,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 139,
              "end_line": 191,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "mgr",
            "on_back"
          ],
          "decorators": [],
          "start_line": 11,
          "end_line": 26,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_apply_and_save",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 33,
          "end_line": 50,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_enter_main",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 52,
          "end_line": 91,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_handle_submenu",
          "args": [
            "self",
            "e"
          ],
          "decorators": [],
          "start_line": 93,
          "end_line": 134,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_go_back",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 136,
          "end_line": 137,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 139,
          "end_line": 191,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "core.settings",
        "systems.audio",
        "core.strings",
        "ui.theme"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame\nfrom core.settings import load_settings, save_settings\nfrom systems.audio import apply_settings\nfrom core.strings import t\nfrom ui.theme import COLORS, get_font\n\nLANG_CODES = ['en-US','pt-BR']\n\nclass SceneSettings:\n    def __init__(self, mgr, on_back=None):\n        self.mgr = mgr\n        self.on_back = on_back\n        self.font_title = get_font(52)\n        self.font = get_font(32)\n        self.small = get_font(22)\n        self.st = load_settings()\n        self.lang = self.st.get('language','en-US')\n        # items are ids; display uses t('settings.<id>')\n        self.main_ids = ['resolution','fps','audio','mute','difficulty','controls','language','show_missing','back']\n        self.sel = 0\n        self.mode = 'main'  # main | resolution | fps | difficulty | audio | controls | language\n        self.res_list = [(1280,720), (1600,900), (1920,1080)]\n        self.fps_list = [30, 60]\n        self.diff_list = ['easy','normal','hard']\n        self.sub_index = 0\n\n    def _apply_and_save(self):\n        save_settings(self.st)\n        try: apply_settings()\n        except Exception: pass\n\n    def handle(self, events):\n        for e in events:\n            if e.type != pygame.KEYDOWN: \n                continue\n            if self.mode == 'main':\n                if e.key in (pygame.K_UP, pygame.K_w):\n                    self.sel = (self.sel - 1) % len(self.main_ids)\n                elif e.key in (pygame.K_DOWN, pygame.K_s):\n                    self.sel = (self.sel + 1) % len(self.main_ids)\n                elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                    self._enter_main()\n                elif e.key == pygame.K_ESCAPE:\n                    self._go_back()\n            else:\n                if e.key in (pygame.K_ESCAPE,):\n                    self.mode = 'main'\n                elif e.key in (pygame.K_UP, pygame.K_w, pygame.K_DOWN, pygame.K_s, pygame.K_RETURN, pygame.K_SPACE):\n                    self._handle_submenu(e)\n\n    def _enter_main(self):\n        cur_id = self.main_ids[self.sel]\n        if cur_id == 'resolution':\n            self.mode = 'resolution'\n            try:\n                self.sub_index = max(0, self.res_list.index(tuple(self.st.get('resolution',(1280,720)))))\n            except ValueError:\n                self.sub_index = 0\n        elif cur_id == 'fps':\n            self.mode = 'fps'\n            try:\n                self.sub_index = max(0, self.fps_list.index(int(self.st.get('fps',60))))\n            except ValueError:\n                self.sub_index = 1\n        elif cur_id == 'audio':\n            self.mode = 'audio'\n        elif cur_id == 'mute':\n            self.st['mute'] = not self.st.get('mute', False)\n            self._apply_and_save()\n        elif cur_id == 'difficulty':\n            self.mode = 'difficulty'\n            curd = self.st.get('difficulty','normal')\n            try:\n                self.sub_index = max(0, self.diff_list.index(curd))\n            except ValueError:\n                self.sub_index = 1\n        elif cur_id == 'controls':\n            self.mode = 'controls'\n        elif cur_id == 'show_missing':\n            self.st['show_missing'] = not self.st.get('show_missing', False)\n            self._apply_and_save()\n        elif cur_id == 'language':\n            self.mode = 'language'\n            cur = self.st.get('language','en-US')\n            try:\n                self.sub_index = LANG_CODES.index(cur)\n            except ValueError:\n                self.sub_index = 0\n        else:\n            self._go_back()\n\n    def _handle_submenu(self, e: pygame.event.Event):\n        if self.mode == 'resolution':\n            if e.key in (pygame.K_UP, pygame.K_w):\n                self.sub_index = (self.sub_index - 1) % len(self.res_list)\n            elif e.key in (pygame.K_DOWN, pygame.K_s):\n                self.sub_index = (self.sub_index + 1) % len(self.res_list)\n            elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                self.st['resolution'] = list(self.res_list[self.sub_index])\n                self._apply_and_save(); self.mode = 'main'\n        elif self.mode == 'fps':\n            if e.key in (pygame.K_UP, pygame.K_w):\n                self.sub_index = (self.sub_index - 1) % len(self.fps_list)\n            elif e.key in (pygame.K_DOWN, pygame.K_s):\n                self.sub_index = (self.sub_index + 1) % len(self.fps_list)\n            elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                self.st['fps'] = int(self.fps_list[self.sub_index])\n                self._apply_and_save(); self.mode = 'main'\n        elif self.mode == 'difficulty':\n            if e.key in (pygame.K_UP, pygame.K_w):\n                self.sub_index = (self.sub_index - 1) % len(self.diff_list)\n            elif e.key in (pygame.K_DOWN, pygame.K_s):\n                self.sub_index = (self.sub_index + 1) % len(self.diff_list)\n            elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                self.st['difficulty'] = self.diff_list[self.sub_index]\n                self._apply_and_save(); self.mode = 'main'\n        elif self.mode == 'audio':\n            vol = int(self.st.get('volume',100))\n            if e.key in (pygame.K_UP, pygame.K_w): vol = min(100, vol + 1)\n            elif e.key in (pygame.K_DOWN, pygame.K_s): vol = max(0, vol - 1)\n            elif e.key in (pygame.K_RETURN, pygame.K_SPACE): self.mode = 'main'; return\n            self.st['volume'] = vol; self._apply_and_save()\n        elif self.mode == 'controls':\n            if e.key in (pygame.K_RETURN, pygame.K_SPACE, pygame.K_ESCAPE): self.mode = 'main'\n        elif self.mode == 'language':\n            if e.key in (pygame.K_UP, pygame.K_w):\n                self.sub_index = (self.sub_index - 1) % len(LANG_CODES)\n            elif e.key in (pygame.K_DOWN, pygame.K_s):\n                self.sub_index = (self.sub_index + 1) % len(LANG_CODES)\n            elif e.key in (pygame.K_RETURN, pygame.K_SPACE):\n                self.st['language'] = LANG_CODES[self.sub_index]\n                self.lang = self.st['language']\n                self._apply_and_save(); self.mode = 'main'\n\n    def _go_back(self):\n        if self.on_back: self.on_back()\n\n    def draw(self, screen):\n        screen.fill((12, 14, 18))\n        # title\n        screen.blit(self.font_title.render(t('settings.title', self.lang), True, COLORS['heading']), (48, 36))\n        if self.mode == 'main':\n            y = 160\n            for i, sid in enumerate(self.main_ids):\n                col = (255,255,210) if i == self.sel else (200,200,200)\n                name = t('settings.'+sid, self.lang)\n                val = ''\n                if sid == 'resolution': val = f\"{tuple(self.st.get('resolution',(1280,720)))}\"\n                elif sid == 'fps': val = f\"{self.st.get('fps',60)}\"\n                elif sid == 'audio': val = f\"{self.st.get('volume',100)}%\"\n                elif sid == 'mute': val = 'On' if self.st.get('mute',False) else 'Off'\n                elif sid == 'difficulty': val = self.st.get('difficulty','normal')\n                elif sid == 'language':\n                    cur = self.st.get('language','en-US')\n                    names = t('settings.lang.values', self.lang)\n                    idx = LANG_CODES.index(cur) if cur in LANG_CODES else 0\n                    val = names[idx]\n                text = f\"{name}\" + (f\" — {val}\" if val else \"\")\n                screen.blit(self.font.render(text, True, col), (72, y)); y += 44\n        else:\n            y = 160\n            title_map = {\n                'resolution': 'settings.resolution','fps':'settings.fps','difficulty':'settings.difficulty','audio':'settings.audio','controls':'settings.controls','language':'settings.language'\n            }\n            screen.blit(self.font.render(t(title_map.get(self.mode,'settings.title'), self.lang), True, (230,230,230)), (72, 120))\n            if self.mode == 'resolution':\n                for i, opt in enumerate(self.res_list):\n                    col = (255,255,210) if i == self.sub_index else (200,200,200)\n                    screen.blit(self.font.render(f\"{opt}\", True, col), (92, y)); y += 42\n            elif self.mode == 'fps':\n                for i, opt in enumerate(self.fps_list):\n                    col = (255,255,210) if i == self.sub_index else (200,200,200)\n                    screen.blit(self.font.render(str(opt), True, col), (92, y)); y += 42\n            elif self.mode == 'difficulty':\n                for i, opt in enumerate(self.diff_list):\n                    col = (255,255,210) if i == self.sub_index else (200,200,200)\n                    screen.blit(self.font.render(opt.title(), True, col), (92, y)); y += 42\n            elif self.mode == 'audio':\n                vol = self.st.get('volume',100)\n                msg = f\"Volume: {vol}% (↑/↓ adjust, ENTER ok)\"\n                screen.blit(self.font.render(msg, True, (220,220,220)), (72, y))\n            elif self.mode == 'controls':\n                msg = \"Controls: remap (soon). ENTER/ESC back.\"\n                screen.blit(self.font.render(msg, True, (220,220,220)), (72, y))\n            elif self.mode == 'language':\n                names = t('settings.lang.values', self.lang)\n                for i, code in enumerate(LANG_CODES):\n                    label = names[i] if i < len(names) else code\n                    col = (255,255,210) if i == self.sub_index else (200,200,200)\n                    screen.blit(self.font.render(label, True, col), (92, y)); y += 42\n"
    },
    {
      "path": "gameplay\\scene_start.py",
      "loc": 39,
      "classes": [
        {
          "name": "SceneStart",
          "start_line": 6,
          "end_line": 38,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "mgr"
              ],
              "decorators": [],
              "start_line": 7,
              "end_line": 12,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 14,
              "end_line": 18,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 20,
              "end_line": 21,
              "draw_suspect": false
            },
            {
              "name": "_ensure_fx",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 23,
              "end_line": 28,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 30,
              "end_line": 38,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "mgr"
          ],
          "decorators": [],
          "start_line": 7,
          "end_line": 12,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 14,
          "end_line": 18,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 20,
          "end_line": 21,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_ensure_fx",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 23,
          "end_line": 28,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 30,
          "end_line": 38,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "core.asset",
        "core.ui_fx",
        "gameplay.scene_mainmenu"
      ],
      "uses_pygame": true,
      "source_code": "# gameplay/scene_start.py — Start usa start_screen.png (FIT), sem dragons\nimport pygame\nfrom core.asset import load_image_strict\nfrom core.ui_fx import blit_fit, make_vignette, make_grain, tint\n\nclass SceneStart:\n    def __init__(self, mgr):\n        self.mgr = mgr\n        self.img = load_image_strict('ui/start_screen.png')\n        self._fx_size = None\n        self.vignette = None\n        self.grain = None\n\n    def handle(self, events):\n        for e in events:\n            if e.type in (pygame.KEYDOWN, pygame.MOUSEBUTTONDOWN):\n                from gameplay.scene_mainmenu import SceneMainMenu\n                self.mgr.switch_to(SceneMainMenu(self.mgr))\n\n    def update(self, dt):\n        pass\n\n    def _ensure_fx(self, screen):\n        size = screen.get_size()\n        if self._fx_size != size:\n            self._fx_size = size\n            self.vignette = make_vignette(size, strength=0.75)\n            self.grain = make_grain(size, intensity=26)\n\n    def draw(self, screen):\n        if self.img:\n            blit_fit(screen, self.img)\n        else:\n            screen.fill((8, 10, 14))\n        self._ensure_fx(screen)\n        tint(screen, color=(20,28,42), alpha=36)\n        if self.vignette: screen.blit(self.vignette, (0,0))\n        if self.grain: screen.blit(self.grain, (0,0))\n"
    },
    {
      "path": "gameplay\\__init__.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "\"\"\"Package\"\"\"\n"
    },
    {
      "path": "systems\\audio.py",
      "loc": 26,
      "classes": [],
      "functions": [
        {
          "name": "ensure_audio",
          "args": [],
          "decorators": [],
          "start_line": 7,
          "end_line": 17,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "apply_settings",
          "args": [],
          "decorators": [],
          "start_line": 19,
          "end_line": 25,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "core.settings"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame\nfrom core.settings import load_settings\n\n_inited = False\n\ndef ensure_audio():\n    global _inited\n    if _inited:\n        return\n    try:\n        pygame.mixer.init()\n    except Exception:\n        # ambiente sem áudio\n        return\n    _inited = True\n    apply_settings()\n\ndef apply_settings():\n    st = load_settings()\n    vol = 0.0 if st.get('mute') else (st.get('volume', 100) / 100.0)\n    try:\n        pygame.mixer.music.set_volume(vol)\n    except Exception:\n        pass\n"
    },
    {
      "path": "systems\\combat.py",
      "loc": 21,
      "classes": [
        {
          "name": "Fighter",
          "start_line": 5,
          "end_line": 20,
          "methods": [
            {
              "name": "alive",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 8,
              "end_line": 8,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 9,
              "end_line": 10,
              "draw_suspect": false
            },
            {
              "name": "try_attack",
              "args": [
                "self",
                "target",
                "style"
              ],
              "decorators": [],
              "start_line": 11,
              "end_line": 20,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "alive",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 8,
          "end_line": 8,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 9,
          "end_line": 10,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "try_attack",
          "args": [
            "self",
            "target",
            "style"
          ],
          "decorators": [],
          "start_line": 11,
          "end_line": 20,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "dataclasses"
      ],
      "uses_pygame": false,
      "source_code": "\nfrom dataclasses import dataclass\n\n@dataclass\nclass Fighter:\n    HP: int; STA: int; MP: int; STR: int; DEX: int; INT: int\n    atk_cool: float = 0.0\n    def alive(self) -> bool: return self.HP > 0\n    def update(self, dt: float):\n        if self.atk_cool > 0: self.atk_cool = max(0.0, self.atk_cool - dt)\n    def try_attack(self, target: 'Fighter', style: str = 'melee') -> tuple[bool,int]:\n        if self.atk_cool > 0: return False, 0\n        dmg = 3\n        if style == 'melee': dmg += self.STR // 2\n        elif style == 'ranged': dmg += self.DEX // 2\n        elif style == 'magic' and self.MP >= 5:\n            dmg += self.INT // 2 + 3; self.MP -= 5\n        target.HP = max(0, target.HP - dmg)\n        self.atk_cool = 0.6\n        return True, dmg\n"
    },
    {
      "path": "systems\\dungeon.py",
      "loc": 21,
      "classes": [],
      "functions": [
        {
          "name": "generate_dungeon",
          "args": [
            "origin_col",
            "origin_row",
            "cols",
            "rows"
          ],
          "decorators": [],
          "start_line": 4,
          "end_line": 20,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "carve_room",
          "args": [
            "x",
            "y",
            "w",
            "h"
          ],
          "decorators": [],
          "start_line": 7,
          "end_line": 10,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "random"
      ],
      "uses_pygame": false,
      "source_code": "# systems/dungeon.py — masmorra simples em grade\nimport random\n\ndef generate_dungeon(origin_col, origin_row, cols=12, rows=12):\n    grid = [['rocky_01' for _ in range(cols)] for __ in range(rows)]\n    # cavar alguns corredores e salas\n    def carve_room(x,y,w,h):\n        for r in range(y, min(rows, y+h)):\n            for c in range(x, min(cols, x+w)):\n                grid[r][c] = 'dirt_01'\n    for _ in range(6):\n        rw = random.randint(3,5); rh = random.randint(3,5)\n        rx = random.randint(1, cols-rw-1); ry = random.randint(1, rows-rh-1)\n        carve_room(rx, ry, rw, rh)\n    # return absolute positions (in tile coords)\n    return {\n        'name':'dungeon',\n        'grid': grid,\n        'origin': (origin_col, origin_row)\n    }\n"
    },
    {
      "path": "systems\\enemy_ai.py",
      "loc": 38,
      "classes": [
        {
          "name": "Enemy",
          "start_line": 11,
          "end_line": 37,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "x",
                "y"
              ],
              "decorators": [],
              "start_line": 12,
              "end_line": 24,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt",
                "player_pos",
                "collidables"
              ],
              "decorators": [],
              "start_line": 25,
              "end_line": 37,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "x",
            "y"
          ],
          "decorators": [],
          "start_line": 12,
          "end_line": 24,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt",
            "player_pos",
            "collidables"
          ],
          "decorators": [],
          "start_line": 25,
          "end_line": 37,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "random",
        "systems.stats",
        "systems.combat",
        "math"
      ],
      "uses_pygame": true,
      "source_code": "# systems/enemy_ai.py — inimigo humanoide simples\nimport pygame, random\nfrom systems.stats import build_stats, RACES, CLASSES\nfrom systems.combat import Fighter\n\nCOLORS = {\n    'Guerreiro': (170,80,60), 'Arcanista': (100,80,160), 'Viajante':(70,140,120),\n    'Arqueiro':(60,140,60), 'Sombra':(80,80,80), 'Trovador':(160,120,80), 'Guardião':(140,120,80)\n}\n\nclass Enemy(pygame.sprite.Sprite):\n    def __init__(self, x, y):\n        super().__init__()\n        race = random.choice(list(RACES.keys()))\n        clazz = random.choice(list(CLASSES.keys()))\n        self.gender = random.choice(['Masculino','Feminino','Não-binário'])\n        self.race = race; self.clazz = clazz\n        stats = build_stats(race, clazz)\n        self.fighter = Fighter(stats)\n        self.image = pygame.Surface((32,48), pygame.SRCALPHA)\n        self.image.fill((*COLORS.get(clazz,(120,120,120)), 255))\n        pygame.draw.rect(self.image, (0,0,0), (0,0,32,48), 1)\n        self.rect = self.image.get_rect(topleft=(x,y))\n        self.speed = 80\n    def update(self, dt, player_pos, collidables):\n        self.fighter.update(dt)\n        # perseguir player\n        px, py = player_pos\n        dx = px - self.rect.centerx; dy = py - self.rect.centery\n        dist2 = dx*dx + dy*dy\n        if dist2 < 400**2:\n            import math\n            d = math.hypot(dx,dy)\n            if d>1:\n                vx, vy = dx/d, dy/d\n                self.rect.x += int(vx*self.speed*dt)\n                self.rect.y += int(vy*self.speed*dt)\n"
    },
    {
      "path": "systems\\fx.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "systems\\inventory.py",
      "loc": 22,
      "classes": [
        {
          "name": "Inventory",
          "start_line": 4,
          "end_line": 21,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 5,
              "end_line": 8,
              "draw_suspect": false
            },
            {
              "name": "add",
              "args": [
                "self",
                "item_id",
                "qty"
              ],
              "decorators": [],
              "start_line": 9,
              "end_line": 10,
              "draw_suspect": false
            },
            {
              "name": "remove",
              "args": [
                "self",
                "item_id",
                "qty"
              ],
              "decorators": [],
              "start_line": 11,
              "end_line": 16,
              "draw_suspect": false
            },
            {
              "name": "can_afford",
              "args": [
                "self",
                "amount"
              ],
              "decorators": [],
              "start_line": 17,
              "end_line": 17,
              "draw_suspect": false
            },
            {
              "name": "spend",
              "args": [
                "self",
                "amount"
              ],
              "decorators": [],
              "start_line": 18,
              "end_line": 20,
              "draw_suspect": false
            },
            {
              "name": "earn",
              "args": [
                "self",
                "amount"
              ],
              "decorators": [],
              "start_line": 21,
              "end_line": 21,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 5,
          "end_line": 8,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "add",
          "args": [
            "self",
            "item_id",
            "qty"
          ],
          "decorators": [],
          "start_line": 9,
          "end_line": 10,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "remove",
          "args": [
            "self",
            "item_id",
            "qty"
          ],
          "decorators": [],
          "start_line": 11,
          "end_line": 16,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "can_afford",
          "args": [
            "self",
            "amount"
          ],
          "decorators": [],
          "start_line": 17,
          "end_line": 17,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "spend",
          "args": [
            "self",
            "amount"
          ],
          "decorators": [],
          "start_line": 18,
          "end_line": 20,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "earn",
          "args": [
            "self",
            "amount"
          ],
          "decorators": [],
          "start_line": 21,
          "end_line": 21,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "typing"
      ],
      "uses_pygame": false,
      "source_code": "# systems/inventory.py — inventário simples com ouro\nfrom typing import Dict, List\n\nclass Inventory:\n    def __init__(self):\n        self.gold = 0\n        self.items: Dict[str, int] = {}\n        self.equipped: Dict[str, str] = {}  # slot->item_id\n    def add(self, item_id: str, qty: int=1):\n        self.items[item_id] = self.items.get(item_id,0) + qty\n    def remove(self, item_id: str, qty: int=1):\n        if self.items.get(item_id,0) >= qty:\n            self.items[item_id] -= qty\n            if self.items[item_id] <= 0: self.items.pop(item_id, None)\n            return True\n        return False\n    def can_afford(self, amount: int) -> bool: return self.gold >= amount\n    def spend(self, amount: int) -> bool:\n        if self.gold >= amount: self.gold -= amount; return True\n        return False\n    def earn(self, amount: int): self.gold += amount\n"
    },
    {
      "path": "systems\\iso_math.py",
      "loc": 13,
      "classes": [],
      "functions": [
        {
          "name": "grid_to_screen",
          "args": [
            "r",
            "c"
          ],
          "decorators": [],
          "start_line": 4,
          "end_line": 7,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "screen_to_grid",
          "args": [
            "x",
            "y"
          ],
          "decorators": [],
          "start_line": 9,
          "end_line": 12,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "core.config"
      ],
      "uses_pygame": false,
      "source_code": "\nfrom core.config import TILE_W, TILE_H\n\ndef grid_to_screen(r: float, c: float) -> tuple[int, int]:\n    x = int((c - r) * (TILE_W // 2))\n    y = int((c + r) * (TILE_H // 2))\n    return x, y\n\ndef screen_to_grid(x: float, y: float) -> tuple[float, float]:\n    r = (y / (TILE_H / 2) - x / (TILE_W / 2)) / 2\n    c = (y / (TILE_H / 2) + x / (TILE_W / 2)) / 2\n    return r, c\n"
    },
    {
      "path": "systems\\items.py",
      "loc": 30,
      "classes": [],
      "functions": [],
      "imports": [
        "typing"
      ],
      "uses_pygame": false,
      "source_code": "# systems/items.py — itens e loot por classe\nfrom typing import Dict, List\n\nITEMS: Dict[str, dict] = {\n    # armas\n    'sword_basic':   {'type':'weapon','class':'Guerreiro','atk':5},\n    'axe_basic':     {'type':'weapon','class':'Guardião','atk':6},\n    'bow_basic':     {'type':'weapon','class':'Arqueiro','atk':5},\n    'dagger_basic':  {'type':'weapon','class':'Sombra','atk':4},\n    'staff_basic':   {'type':'weapon','class':'Arcanista','atk':3,'mag':4},\n    # armaduras\n    'armor_light':   {'type':'armor','class':'Viajante','def':3},\n    'armor_heavy':   {'type':'armor','class':'Guardião','def':6},\n    'robe_basic':    {'type':'armor','class':'Arcanista','def':1,'mag':2},\n    # consumíveis\n    'potion_hp':     {'type':'consumable','hp':20},\n    'potion_sta':    {'type':'consumable','sta':15},\n    'potion_mp':     {'type':'consumable','mp':15},\n}\n\nLOOT_BY_CLASS: Dict[str, List[str]] = {\n    'Guerreiro': ['sword_basic','armor_light','potion_hp'],\n    'Arcanista': ['staff_basic','robe_basic','potion_mp'],\n    'Viajante':  ['armor_light','dagger_basic','potion_sta'],\n    'Arqueiro':  ['bow_basic','armor_light','potion_hp'],\n    'Sombra':    ['dagger_basic','armor_light','potion_sta'],\n    'Trovador':  ['armor_light','potion_hp','potion_mp'],\n    'Guardião':  ['axe_basic','armor_heavy','potion_hp'],\n}\n"
    },
    {
      "path": "systems\\loot.py",
      "loc": 28,
      "classes": [],
      "functions": [
        {
          "name": "roll_loot",
          "args": [
            "biome",
            "rng"
          ],
          "decorators": [],
          "start_line": 20,
          "end_line": 26,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "random"
      ],
      "uses_pygame": false,
      "source_code": "\nimport random\n\nBIOME_LOOT = {\n    'grass': ['ervas', 'peles', 'carne_crua', 'seta'],\n    'forest': ['madeira', 'fruta_silvestre', 'erva_rara', 'fungo'],\n    'snow': ['gelo', 'peles_grossas', 'mineral_raro'],\n    'water': ['peixe', 'alga', 'pérola'],\n    'dirt': ['argila', 'minério_ferro', 'pedra'],\n}\n\nPRICES = {\n    'ervas': 2, 'peles': 5, 'carne_crua': 3, 'seta': 1,\n    'madeira': 2, 'fruta_silvestre': 1, 'erva_rara': 12, 'fungo': 3,\n    'gelo': 1, 'peles_grossas': 7, 'mineral_raro': 20,\n    'peixe': 4, 'alga': 2, 'pérola': 30,\n    'argila': 2, 'minério_ferro': 8, 'pedra': 1,\n}\n\ndef roll_loot(biome: str, rng: random.Random | None = None) -> list[str]:\n    rnd = rng or random.Random()\n    pool = BIOME_LOOT.get(biome, [])\n    if not pool:\n        return []\n    n = rnd.randint(1, 3)\n    return [rnd.choice(pool) for _ in range(n)]\n\n"
    },
    {
      "path": "systems\\mapgen.py",
      "loc": 43,
      "classes": [],
      "functions": [
        {
          "name": "generate",
          "args": [
            "cols",
            "rows",
            "seed"
          ],
          "decorators": [],
          "start_line": 5,
          "end_line": 42,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "smooth",
          "args": [
            "g"
          ],
          "decorators": [],
          "start_line": 30,
          "end_line": 40,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "random",
        "math"
      ],
      "uses_pygame": false,
      "source_code": "# systems/mapgen.py — safe topdown biomes; returns tokens only (no assets)\nimport random\nfrom math import hypot\n\ndef generate(cols=64, rows=64, seed=2025):\n    rng = random.Random(seed)\n    lake_c = (int(cols*0.30), int(rows*0.60))\n    mount_c = (int(cols*0.75), int(rows*0.25))\n    grid = [['' for _ in range(cols)] for __ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            dl = hypot(c-lake_c[0], r-lake_c[1])\n            dm = hypot(c-mount_c[0], r-mount_c[1])\n            if dl < 4.0:\n                token = 'water_01'\n            elif dl < 6.0:\n                token = 'sand_01'\n            else:\n                h = dm - dl\n                if h < -8:\n                    token = 'grass_01'\n                elif h < 6:\n                    token = 'grass_01' if rng.random()<0.9 else 'path_01'\n                elif h < 12:\n                    token = 'rocky_01'\n                else:\n                    token = 'snow_01'\n            grid[r][c] = token\n    # light smoothing\n    def smooth(g):\n        rows=len(g); cols=len(g[0])\n        out=[row[:] for row in g]\n        for r in range(rows):\n            for c in range(cols):\n                cnt={}\n                for rr in range(max(0,r-1), min(rows,r+2)):\n                    for cc in range(max(0,c-1), min(cols,c+2)):\n                        t=g[rr][cc]; cnt[t]=cnt.get(t,0)+1\n                out[r][c] = max(cnt, key=cnt.get)\n        return out\n    grid = smooth(grid)\n    return grid\n"
    },
    {
      "path": "systems\\mapgen_iso.py",
      "loc": 118,
      "classes": [],
      "functions": [
        {
          "name": "_carve_path",
          "args": [
            "ground",
            "a",
            "b",
            "token"
          ],
          "decorators": [],
          "start_line": 4,
          "end_line": 14,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_ellipse_fill",
          "args": [
            "ground",
            "center",
            "rx",
            "ry",
            "token"
          ],
          "decorators": [],
          "start_line": 16,
          "end_line": 24,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_rect_centered",
          "args": [
            "center",
            "w",
            "h"
          ],
          "decorators": [],
          "start_line": 26,
          "end_line": 29,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_apply_mountain",
          "args": [
            "ground",
            "center",
            "size"
          ],
          "decorators": [],
          "start_line": 31,
          "end_line": 52,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "generate_world",
          "args": [
            "cols",
            "rows"
          ],
          "decorators": [],
          "start_line": 55,
          "end_line": 118,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "random",
        "math"
      ],
      "uses_pygame": false,
      "source_code": "# systems/mapgen_iso.py  (adicione abaixo do arquivo existente)\nimport random, math\n\ndef _carve_path(ground, a, b, token='path_01'):\n    \"\"\"Linha com jitter leve entre dois pontos (r,c) -> marca path no ground.\"\"\"\n    r0, c0 = a; r1, c1 = b\n    r, c = r0, c0\n    steps = max(abs(r1-r0), abs(c1-c0)) + 1\n    for i in range(steps):\n        t = 0 if steps<=1 else i/(steps-1)\n        rr = int(round(r0 + (r1 - r0)*t + random.uniform(-0.2,0.2)))\n        cc = int(round(c0 + (c1 - c0)*t + random.uniform(-0.2,0.2)))\n        if 0 <= rr < len(ground) and 0 <= cc < len(ground[0]):\n            ground[rr][cc] = token\n\ndef _ellipse_fill(ground, center, rx, ry, token):\n    cr, cc = center\n    rows, cols = len(ground), len(ground[0])\n    for r in range(max(0, cr-ry-2), min(rows, cr+ry+3)):\n        for c in range(max(0, cc-rx-2), min(cols, cc+rx+3)):\n            x = (c - cc) / max(1.0, rx)\n            y = (r - cr) / max(1.0, ry)\n            if x*x + y*y <= 1.0:\n                ground[r][c] = token\n\ndef _rect_centered(center, w, h):\n    r0 = center[0] - h//2\n    c0 = center[1] - w//2\n    return (r0, c0, h, w)  # (top, left, height, width)\n\ndef _apply_mountain(ground, center, size):\n    \"\"\"Preenche uma caixa central com gradiente radial: snow->rocky->dirt.\"\"\"\n    rows, cols = len(ground), len(ground[0])\n    mr, mc = center\n    mh, mw = size\n    r_top = max(0, mr - mh//2); r_bot = min(rows, mr + mh//2)\n    c_left = max(0, mc - mw//2); c_right = min(cols, mc + mw//2)\n    # raio para normalização\n    rx = mw/2.0; ry = mh/2.0\n    for r in range(r_top, r_bot):\n        for c in range(c_left, c_right):\n            x = (c - mc) / max(1.0, rx)\n            y = (r - mr) / max(1.0, ry)\n            d = math.sqrt(x*x + y*y)  # 0 centro → 1 borda\n            # pequenas irregularidades\n            d += random.uniform(-0.05, 0.05)\n            if d <= 0.40:\n                ground[r][c] = 'snow_01'\n            elif d <= 0.70:\n                ground[r][c] = 'rocky_01'\n            elif d <= 0.85:\n                ground[r][c] = 'dirt_01'\n            # fora da borda, mantém o que já tinha\n\ndef generate_world(cols: int = 128, rows: int = 128, *, mountain_frac: float = 0.5, seed: int | None = None):\n    \"\"\"\n    Mundo isométrico com:\n    - Montanha central ocupando ~metade do mapa (fração do menor lado)\n    - Lago + areia\n    - Caminhos entre POIs\n    Retorna: {'layers':[{'name':'ground','grid':...}], 'player_start':(r,c), 'pois':{...}}\n    \"\"\"\n    rnd = random.Random(seed)\n    rows = int(rows); cols = int(cols)\n    # 1) base: grama\n    ground = [['grass_01' for _ in range(cols)] for __ in range(rows)]\n\n    # 2) lago (elipse) – lateral superior/esquerda\n    lake_center = (rows//3, cols//3)\n    rx, ry = max(6, cols//10), max(5, rows//10)\n    _ellipse_fill(ground, lake_center, rx, ry, 'water_01')\n    # faixa de areia ao redor (um pouco maior)\n    _ellipse_fill(ground, lake_center, int(rx*1.15), int(ry*1.12), 'sand_01')\n\n    # 3) montanha central (retângulo ~ metade do mapa)\n    k = max(4, int(min(rows, cols) * mountain_frac))\n    mh = min(rows-4, k)\n    mw = min(cols-4, k)\n    center = (rows//2, cols//2)\n    _apply_mountain(ground, center, (mh, mw))\n    mountain_bbox = _rect_centered(center, mw, mh)\n\n    # 4) “vila” (solo): área de terra batida próxima à grama e longe do lago\n    village_center = (rows - rows//4, cols//4*3)\n    vh, vw = max(8, rows//10), max(10, cols//10)\n    v_top = max(0, village_center[0] - vh//2)\n    v_left = max(0, village_center[1] - vw//2)\n    for r in range(v_top, min(rows, v_top+vh)):\n        for c in range(v_left, min(cols, v_left+vw)):\n            ground[r][c] = 'dirt_01'\n    player_start = (village_center[0], village_center[1])\n\n    # 5) “entradas” em encostas (para futura caverna/masmorra)\n    # pontinhos nas laterais da montanha\n    mr, mc = center\n    cave_a = (mr, mc - mw//2 - 2)  # lado oeste (fora 2 tiles)\n    cave_b = (mr + mh//4, mc + mw//2 + 2)  # lado leste-sul\n    cave_entrances = [cave_a, cave_b]\n\n    # 6) caminhos conectando pontos de interesse\n    # vila -> montanha\n    _carve_path(ground, player_start, (mr + mh//2, mc))\n    # vila -> lago\n    _carve_path(ground, player_start, lake_center)\n    # lago -> montanha\n    _carve_path(ground, lake_center, (mr, mc))\n    # montanha -> caves\n    for cv in cave_entrances:\n        _carve_path(ground, (mr, mc), cv)\n\n    layers = [{'name': 'ground', 'grid': ground}]\n    pois = {\n        'village_center': village_center,\n        'mountain_bbox': mountain_bbox,  # (top, left, h, w)\n        'lake_center': lake_center,\n        'cave_entrances': cave_entrances,\n    }\n    return {'layers': layers, 'player_start': player_start, 'pois': pois}"
    },
    {
      "path": "systems\\npc.py",
      "loc": 27,
      "classes": [
        {
          "name": "Shopkeeper",
          "start_line": 6,
          "end_line": 26,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "x",
                "y",
                "stock"
              ],
              "decorators": [],
              "start_line": 7,
              "end_line": 14,
              "draw_suspect": false
            },
            {
              "name": "open_shop",
              "args": [
                "self",
                "player_inventory"
              ],
              "decorators": [],
              "start_line": 16,
              "end_line": 26,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "x",
            "y",
            "stock"
          ],
          "decorators": [],
          "start_line": 7,
          "end_line": 14,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "open_shop",
          "args": [
            "self",
            "player_inventory"
          ],
          "decorators": [],
          "start_line": 16,
          "end_line": 26,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "systems.items",
        "systems.inventory"
      ],
      "uses_pygame": true,
      "source_code": "# systems/npc.py — NPCs e lojista\nimport pygame\nfrom systems.items import ITEMS\nfrom systems.inventory import Inventory\n\nclass Shopkeeper(pygame.sprite.Sprite):\n    def __init__(self, x, y, stock=None):\n        super().__init__()\n        self.image = pygame.Surface((32,48), pygame.SRCALPHA)\n        self.image.fill((200,170,90))\n        pygame.draw.rect(self.image, (0,0,0), (0,0,32,48), 1)\n        self.rect = self.image.get_rect(topleft=(x,y))\n        self.stock = stock or {'potion_hp':5,'potion_sta':5,'potion_mp':5}\n        self.prices = {k: 10 for k in self.stock}\n\n    def open_shop(self, player_inventory: Inventory):\n        # compra simples pela primeira opção disponível\n        for item_id, qty in list(self.stock.items()):\n            price = self.prices.get(item_id, 10)\n            if player_inventory.can_afford(price) and qty>0:\n                # auto-compra 1 item (placeholder de UI)\n                player_inventory.spend(price)\n                player_inventory.add(item_id, 1)\n                self.stock[item_id] -= 1\n                return f'Comprou {item_id} por {price} gold.'\n        return 'Loja sem transação.'\n"
    },
    {
      "path": "systems\\save_load.py",
      "loc": 37,
      "classes": [],
      "functions": [
        {
          "name": "_slot_path",
          "args": [
            "slot"
          ],
          "decorators": [],
          "start_line": 7,
          "end_line": 9,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "list_saves",
          "args": [],
          "decorators": [],
          "start_line": 11,
          "end_line": 12,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "save_game",
          "args": [
            "data",
            "slot"
          ],
          "decorators": [],
          "start_line": 14,
          "end_line": 18,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "load_game",
          "args": [
            "slot_or_path"
          ],
          "decorators": [],
          "start_line": 20,
          "end_line": 27,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "delete_save",
          "args": [
            "slot_or_path"
          ],
          "decorators": [],
          "start_line": 29,
          "end_line": 34,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "has_save_any",
          "args": [],
          "decorators": [],
          "start_line": 36,
          "end_line": 37,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "json",
        "pathlib"
      ],
      "uses_pygame": false,
      "source_code": "import json\nfrom pathlib import Path\n\nSAVES_DIR = Path('saves')\nSAVES_DIR.mkdir(exist_ok=True)\n\ndef _slot_path(slot: int) -> Path:\n    slot = max(1, min(3, int(slot)))\n    return SAVES_DIR / f'save_{slot}.json'\n\ndef list_saves():\n    return [str(_slot_path(s)) for s in (1,2,3) if _slot_path(s).exists()]\n\ndef save_game(data: dict, slot: int = 1):\n    path = _slot_path(slot)\n    with open(path, 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n    return str(path)\n\ndef load_game(slot_or_path):\n    path = _slot_path(slot_or_path) if isinstance(slot_or_path, int) else Path(slot_or_path)\n    if not path.exists():\n        return None\n    try:\n        return json.loads(path.read_text(encoding='utf-8'))\n    except Exception:\n        return None\n\ndef delete_save(slot_or_path) -> bool:\n    path = _slot_path(slot_or_path) if isinstance(slot_or_path, int) else Path(slot_or_path)\n    if path.exists():\n        path.unlink(missing_ok=True)\n        return True\n    return False\n\ndef has_save_any() -> bool:\n    return any(_slot_path(s).exists() for s in (1,2,3))"
    },
    {
      "path": "systems\\stats.py",
      "loc": 37,
      "classes": [
        {
          "name": "Stats",
          "start_line": 22,
          "end_line": 24,
          "methods": []
        }
      ],
      "functions": [
        {
          "name": "build_stats",
          "args": [
            "race",
            "clazz"
          ],
          "decorators": [],
          "start_line": 26,
          "end_line": 36,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "dataclasses"
      ],
      "uses_pygame": false,
      "source_code": "\nfrom dataclasses import dataclass\n\nRACES = {\n    'Norther': {'desc': 'Humanos das terras geladas; robustos, resistentes ao frio.', 'bonus': {'STR': 1, 'VIT': 2}},\n    'Valen':   {'desc': 'Elfos de bosques antigos; olhos aguçados e passos leves.',    'bonus': {'DEX': 2, 'WIS': 1}},\n    'Durn':    {'desc': 'Anões das montanhas; mestres da forja e da tenacidade.',      'bonus': {'STR': 2, 'END': 1}},\n    'Serathi': {'desc': 'Felinos nômades; instintos rápidos e furtivos.',               'bonus': {'DEX': 2, 'INT': 1}},\n    'Aetherborn': {'desc':'Nascidos do éter; afinidade natural com magia.',              'bonus': {'INT': 2, 'WIS': 1}},\n}\n\nCLASSES = {\n    'Guerreiro':  {'desc': 'Combate corpo a corpo, armaduras pesadas.', 'base': {'STR': 4, 'DEX': 1, 'INT': 0, 'VIT': 3, 'END': 3, 'WIS': 0}},\n    'Arqueiro':   {'desc': 'Ataques à distância, mobilidade.',           'base': {'STR': 1, 'DEX': 4, 'INT': 0, 'VIT': 2, 'END': 2, 'WIS': 0}},\n    'Arcanista':  {'desc': 'Magos eruditos, poder místico.',             'base': {'STR': 0, 'DEX': 0, 'INT': 5, 'VIT': 1, 'END': 1, 'WIS': 3}},\n    'Viajante':   {'desc': 'Versátil, sobrevivência e comércio.',        'base': {'STR': 1, 'DEX': 2, 'INT': 1, 'VIT': 2, 'END': 2, 'WIS': 1}},\n    'Sombra':     {'desc': 'Furtividade e assassinato.',                 'base': {'STR': 1, 'DEX': 5, 'INT': 1, 'VIT': 1, 'END': 2, 'WIS': 0}},\n    'Guardiã(o)': {'desc': 'Proteção, fé e disciplina.',                 'base': {'STR': 3, 'DEX': 0, 'INT': 1, 'VIT': 3, 'END': 3, 'WIS': 2}},\n}\n\n@dataclass\nclass Stats:\n    STR: int; DEX: int; INT: int; VIT: int; END: int; WIS: int\n    HP: int; MP: int; STA: int\n\ndef build_stats(race: str, clazz: str) -> 'Stats':\n    base = CLASSES.get(clazz, CLASSES['Guerreiro'])['base'].copy()\n    bonus = RACES.get(race, RACES['Norther'])['bonus']\n    for k, v in bonus.items():\n        base[k] = base.get(k, 0) + v\n    STR, DEX, INT = base['STR'], base['DEX'], base['INT']\n    VIT, END, WIS = base['VIT'], base['END'], base['WIS']\n    hp = 30 + VIT * 8\n    mp = 10 + INT * 8 + WIS * 4\n    sta = 20 + END * 6\n    return Stats(STR, DEX, INT, VIT, END, WIS, hp, mp, sta)\n"
    },
    {
      "path": "systems\\tile_factory.py",
      "loc": 45,
      "classes": [],
      "functions": [
        {
          "name": "_diamond",
          "args": [
            "color",
            "alpha"
          ],
          "decorators": [],
          "start_line": 15,
          "end_line": 22,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "build_tile",
          "args": [
            "token",
            "tile_size"
          ],
          "decorators": [],
          "start_line": 26,
          "end_line": 44,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "core.config"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame\nfrom core.config import TILE_W, TILE_H\n\nCOLORS = {\n    'GRASS': (62, 130, 68),\n    'DIRT': (110, 84, 60),\n    'WATER': (40, 100, 180),\n    'SNOW': (225, 232, 240),\n    'PATH': (160, 140, 100),\n}\n\n_outline = (0, 0, 0, 80)\n\ndef _diamond(color: tuple[int,int,int], alpha: int = 255) -> pygame.Surface:\n    surf = pygame.Surface((TILE_W, TILE_H), pygame.SRCALPHA)\n    cx, cy = TILE_W // 2, TILE_H // 2\n    pts = [(cx, 0), (TILE_W - 1, cy), (cx, TILE_H - 1), (0, cy)]\n    col = (*color, alpha)\n    pygame.draw.polygon(surf, col, pts)\n    pygame.draw.polygon(surf, _outline, pts, 1)\n    return surf\n\n_cache: dict[str, pygame.Surface] = {}\n\ndef build_tile(token: str, tile_size: int | None = None) -> pygame.Surface:\n    key = token\n    if key in _cache:\n        return _cache[key]\n    low = token.lower()\n    if low.startswith('grass'):\n        img = _diamond(COLORS['GRASS'])\n    elif low.startswith('dirt'):\n        img = _diamond(COLORS['DIRT'])\n    elif low.startswith('water') or low.startswith('wather'):\n        img = _diamond(COLORS['WATER'])\n    elif low.startswith('snow'):\n        img = _diamond(COLORS['SNOW'])\n    elif low.startswith('path'):\n        img = _diamond(COLORS['PATH'])\n    else:\n        img = _diamond((150, 150, 150))\n    _cache[key] = img\n    return img\n"
    },
    {
      "path": "systems\\timecycle.py",
      "loc": 52,
      "classes": [
        {
          "name": "GameTime",
          "start_line": 15,
          "end_line": 18,
          "methods": []
        },
        {
          "name": "TimeManager",
          "start_line": 20,
          "end_line": 51,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 21,
              "end_line": 23,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt_real_seconds"
              ],
              "decorators": [],
              "start_line": 24,
              "end_line": 36,
              "draw_suspect": false
            },
            {
              "name": "current_day_part",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 37,
              "end_line": 41,
              "draw_suspect": false
            },
            {
              "name": "current_season",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 42,
              "end_line": 43,
              "draw_suspect": false
            },
            {
              "name": "ambient_tint",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 44,
              "end_line": 51,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 21,
          "end_line": 23,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt_real_seconds"
          ],
          "decorators": [],
          "start_line": 24,
          "end_line": 36,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "current_day_part",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 37,
          "end_line": 41,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "current_season",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 42,
          "end_line": 43,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "ambient_tint",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 44,
          "end_line": 51,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "dataclasses",
        "core.config"
      ],
      "uses_pygame": false,
      "source_code": "# systems/timecycle.py — ciclo de tempo, períodos e estações\nfrom dataclasses import dataclass\nfrom core.config import SECONDS_PER_GAME_DAY\n\nDAY_PARTS = [\n    ('madrugada', 0.00, 0.20),\n    ('manhã',      0.20, 0.40),\n    ('tarde',      0.40, 0.70),\n    ('fim_tarde',  0.70, 0.85),\n    ('noite',      0.85, 1.00),\n]\nSEASONS = ['primavera','verão','outono','inverno']\n\n@dataclass\nclass GameTime:\n    day: int = 1\n    hour: float = 8.0  # começa de manhã\n    season_idx: int = 0  # primavera\n\nclass TimeManager:\n    def __init__(self):\n        self.t = GameTime()\n        self.accum = 0.0\n    def update(self, dt_real_seconds: float):\n        # 10 min reais = 1 dia => SECONDS_PER_GAME_DAY segundos reais = 24h in-game\n        self.accum += dt_real_seconds\n        day_frac_inc = self.accum / SECONDS_PER_GAME_DAY\n        if day_frac_inc <= 0: return\n        self.accum = 0.0\n        hours_inc = day_frac_inc * 24.0\n        self.t.hour += hours_inc\n        while self.t.hour >= 24.0:\n            self.t.hour -= 24.0\n            self.t.day += 1\n            if (self.t.day % 30) == 1:  # a cada 30 dias muda estação\n                self.t.season_idx = (self.t.season_idx + 1) % len(SEASONS)\n    def current_day_part(self) -> str:\n        frac = self.t.hour / 24.0\n        for name, a, b in DAY_PARTS:\n            if a <= frac < b: return name\n        return 'noite'\n    def current_season(self) -> str:\n        return SEASONS[self.t.season_idx]\n    def ambient_tint(self):\n        # retorna um multiplicador de cor (r,g,b,alpha) conforme parte do dia\n        part = self.current_day_part()\n        if part == 'madrugada': return (120,120,160,60)\n        if part == 'manhã':     return (255,255,255,0)\n        if part == 'tarde':     return (255,255,255,0)\n        if part == 'fim_tarde': return (255,200,160,30)\n        return (80,80,120,80)\n"
    },
    {
      "path": "systems\\time_of_day.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "systems\\weather.py",
      "loc": 55,
      "classes": [
        {
          "name": "Weather",
          "start_line": 4,
          "end_line": 54,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "kind",
                "intensity",
                "screen_size"
              ],
              "decorators": [],
              "start_line": 5,
              "end_line": 12,
              "draw_suspect": false
            },
            {
              "name": "resize",
              "args": [
                "self",
                "size"
              ],
              "decorators": [],
              "start_line": 13,
              "end_line": 14,
              "draw_suspect": false
            },
            {
              "name": "_load_assets",
              "args": [
                "self"
              ],
              "decorators": [],
              "start_line": 15,
              "end_line": 34,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt",
                "season",
                "day_part"
              ],
              "decorators": [],
              "start_line": 35,
              "end_line": 44,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 45,
              "end_line": 54,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "kind",
            "intensity",
            "screen_size"
          ],
          "decorators": [],
          "start_line": 5,
          "end_line": 12,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "resize",
          "args": [
            "self",
            "size"
          ],
          "decorators": [],
          "start_line": 13,
          "end_line": 14,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_load_assets",
          "args": [
            "self"
          ],
          "decorators": [],
          "start_line": 15,
          "end_line": 34,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt",
            "season",
            "day_part"
          ],
          "decorators": [],
          "start_line": 35,
          "end_line": 44,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 45,
          "end_line": 54,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "os",
        "pygame",
        "random"
      ],
      "uses_pygame": false,
      "source_code": "# systems/weather.py — clima dependente de estação/parte do dia\nimport os, pygame, random\n\nclass Weather:\n    def __init__(self, kind='rain', intensity=0.6, screen_size=(1280,720)):\n        self.kind = kind\n        self.intensity = max(0.0, min(1.0, float(intensity)))\n        self.screen_w, self.screen_h = screen_size\n        self.offset = 0.0; self.speed = 240\n        self._frames = []; self._frame_idx = 0\n        self._frame_timer = 0.0; self._frame_duration = 1.0/12.0\n        self._load_assets()\n    def resize(self, size):\n        self.screen_w, self.screen_h = size\n    def _load_assets(self):\n        base = os.path.join('assets','weather')\n        name = 'rain.png' if self.kind == 'rain' else 'snow.png'\n        path = os.path.join(base, name)\n        self._frames.clear()\n        if os.path.exists(path):\n            sheet = pygame.image.load(path); sheet = sheet.convert_alpha() if sheet.get_alpha() else sheet.convert()\n            w,h=sheet.get_size(); sliced=False\n            for n in range(8,1,-1):\n                if w % n == 0:\n                    fw=w//n; \n                    if fw>=8:\n                        for i in range(n): self._frames.append(sheet.subsurface((i*fw,0,fw,h)))\n                        sliced=True; break\n            if not sliced: self._frames.append(sheet)\n        else:\n            surf = pygame.Surface((64,64), pygame.SRCALPHA)\n            color = (180,180,255,120) if self.kind=='rain' else (255,255,255,120)\n            for x in range(64): surf.set_at((x,(x*7)%64), color)\n            self._frames.append(surf)\n    def update(self, dt: float=0.0, season: str=None, day_part: str=None):\n        if season:\n            if season == 'inverno': self.kind='snow'\n            elif season in ('primavera','outono','verão'): self.kind='rain'\n        if len(self._frames)>1:\n            self._frame_timer += dt\n            if self._frame_timer >= self._frame_duration:\n                self._frame_timer -= self._frame_duration\n                self._frame_idx = (self._frame_idx + 1) % len(self._frames)\n        self.offset = (self.offset + self.speed * dt) % 1024\n    def draw(self, screen: pygame.Surface):\n        if self.intensity <= 0.01: return\n        frame = self._frames[self._frame_idx]\n        fw,fh = frame.get_size(); ox=int(self.offset)%fw; oy=int(self.offset*0.6)%fh\n        for y in range(-fh, self.screen_h+fh, fh):\n            for x in range(-fw, self.screen_w+fw, fw):\n                screen.blit(frame, (x-ox, y-oy))\n        veil = pygame.Surface((self.screen_w,self.screen_h), pygame.SRCALPHA)\n        veil.fill((0,0,0,int(40*self.intensity)))\n        screen.blit(veil,(0,0))\n"
    },
    {
      "path": "systems\\__init__.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "\"\"\"Package\"\"\"\n"
    },
    {
      "path": "ui\\char_create.py",
      "loc": 87,
      "classes": [
        {
          "name": "CharacterCreation",
          "start_line": 27,
          "end_line": 86,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "mgr"
              ],
              "decorators": [],
              "start_line": 28,
              "end_line": 36,
              "draw_suspect": false
            },
            {
              "name": "handle",
              "args": [
                "self",
                "events"
              ],
              "decorators": [],
              "start_line": 37,
              "end_line": 62,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 63,
              "end_line": 63,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen"
              ],
              "decorators": [],
              "start_line": 64,
              "end_line": 86,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "mgr"
          ],
          "decorators": [],
          "start_line": 28,
          "end_line": 36,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "handle",
          "args": [
            "self",
            "events"
          ],
          "decorators": [],
          "start_line": 37,
          "end_line": 62,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 63,
          "end_line": 63,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen"
          ],
          "decorators": [],
          "start_line": 64,
          "end_line": 86,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "gameplay.scene_game"
      ],
      "uses_pygame": true,
      "source_code": "import pygame\nfrom gameplay.scene_game import SceneGame\n\nGENDERS=['Masculino','Feminino']\nRACES=[\n    ('Valdyr','Nativos das Montanhas Cinzentas; vigorosos e resilientes.'),\n    ('Eldran','Antigos eruditos dos Bosques Pálidos; afinidade arcana.'),\n    ('Karuun','Povos das Planícies de Bronze; força e disciplina.'),\n    ('Sildor','Caçadores do Vale Verde; rápidos e precisos.'),\n    ('Aeliri','Errantes das Brumas Azuis; mente ágil e curiosa.'),\n    ('Morvak','Clãs da Pedra Profunda; pele espessa e vigor.'),\n    ('Tirren','Mercadores do Deserto Dourado; adaptáveis e astutos.'),\n    ('Orruk','Tribo do Ferro Negro; potência bruta, pouca sutileza.'),\n    ('Shaqat','Nômades de Jade; passos silenciosos e olhos atentos.'),\n    ('Nereen','Filhos da Névoa; intuição e talento místico.'),\n]\nCLASSES=[\n    ('Guerreiro','Combate corpo a corpo, alta resistência, controle de espaço.'),\n    ('Arcanista','Magias ofensivas e utilitárias; frágil no início.'),\n    ('Viajante','Versátil, mobilidade e exploração; equilíbrio geral.'),\n    ('Arqueiro','Ataques à distância, alta precisão e kiting.'),\n    ('Sombra','Furtividade, golpes críticos e evasão.'),\n    ('Trovador','Suporte e buffs; controle leve de campo.'),\n    ('Guardião','Tanque; proteção, bloqueio e presença.'),\n]\n\nclass CharacterCreation:\n    def __init__(self, mgr):\n        self.mgr=mgr\n        self.font=pygame.font.SysFont('serif',42)\n        self.small=pygame.font.SysFont('serif',24)\n        self.step=0\n        self.name=''\n        self.gen=0\n        self.race=0\n        self.clazz=0\n    def handle(self, events):\n        for e in events:\n            if e.type==pygame.KEYDOWN:\n                if self.step==0:\n                    if e.key==pygame.K_RETURN and self.name.strip(): self.step=1\n                    elif e.key==pygame.K_BACKSPACE: self.name=self.name[:-1]\n                    else:\n                        ch=e.unicode\n                        if ch and (ch.isalnum() or ch in ' _-') and len(self.name)<16: self.name+=ch\n                elif self.step==1:\n                    if e.key in (pygame.K_LEFT,pygame.K_a): self.gen=(self.gen-1)%len(GENDERS)\n                    elif e.key in (pygame.K_RIGHT,pygame.K_d): self.gen=(self.gen+1)%len(GENDERS)\n                    elif e.key in (pygame.K_RETURN,pygame.K_SPACE): self.step=2\n                    elif e.key==pygame.K_ESCAPE: self.step=0\n                elif self.step==2:\n                    if e.key in (pygame.K_LEFT,pygame.K_a): self.race=(self.race-1)%len(RACES)\n                    elif e.key in (pygame.K_RIGHT,pygame.K_d): self.race=(self.race+1)%len(RACES)\n                    elif e.key in (pygame.K_RETURN,pygame.K_SPACE): self.step=3\n                    elif e.key==pygame.K_ESCAPE: self.step=1\n                elif self.step==3:\n                    if e.key in (pygame.K_LEFT,pygame.K_a): self.clazz=(self.clazz-1)%len(CLASSES)\n                    elif e.key in (pygame.K_RIGHT,pygame.K_d): self.clazz=(self.clazz+1)%len(CLASSES)\n                    elif e.key in (pygame.K_RETURN,pygame.K_SPACE):\n                        profile={'name':self.name.strip(),'gender':GENDERS[self.gen],'race':RACES[self.race][0],'clazz':CLASSES[self.clazz][0]}\n                        self.mgr.scene = SceneGame(self.mgr, profile)\n                    elif e.key==pygame.K_ESCAPE: self.step=2\n    def update(self, dt): pass\n    def draw(self, screen):\n        screen.fill((12,12,18))\n        w,h=screen.get_size()\n        if self.step==0:\n            head=self.font.render('Nome do personagem', True, (236,200,120)); screen.blit(head, head.get_rect(center=(w//2,int(h*0.2))))\n            box=pygame.Rect(0,0, max(400,w//3), 50); box.center=(w//2,h//2)\n            pygame.draw.rect(screen,(24,24,32),box,border_radius=6); pygame.draw.rect(screen,(90,90,120),box,2,border_radius=6)\n            txt=self.font.render(self.name,True,(240,220,160)); screen.blit(txt, txt.get_rect(midleft=(box.left+12, box.centery)))\n        elif self.step==1:\n            head=self.font.render('Gênero',True,(236,200,120)); screen.blit(head, head.get_rect(center=(w//2,int(h*0.2))))\n            opt=self.font.render(GENDERS[self.gen],True,(240,220,160)); screen.blit(opt,opt.get_rect(center=(w//2,h//2)))\n        elif self.step==2:\n            head=self.font.render('Raça',True,(236,200,120)); screen.blit(head, head.get_rect(center=(w//2,int(h*0.18))))\n            nm,desc=RACES[self.race]\n            opt=self.font.render(nm,True,(240,220,160)); screen.blit(opt,opt.get_rect(center=(w//2,int(h*0.42))))\n            wrap = self.small.render(desc, True, (210,210,210))\n            screen.blit(wrap, wrap.get_rect(center=(w//2,int(h*0.55))))\n        elif self.step==3:\n            head=self.font.render('Classe',True,(236,200,120)); screen.blit(head, head.get_rect(center=(w//2,int(h*0.18))))\n            nm,desc=CLASSES[self.clazz]\n            opt=self.font.render(nm,True,(240,220,160)); screen.blit(opt,opt.get_rect(center=(w//2,int(h*0.42))))\n            wrap = self.small.render(desc, True, (210,210,210))\n            screen.blit(wrap, wrap.get_rect(center=(w//2,int(h*0.55))))\n"
    },
    {
      "path": "ui\\hud.py",
      "loc": 57,
      "classes": [],
      "functions": [
        {
          "name": "_draw_bar",
          "args": [
            "surface",
            "x",
            "y",
            "w",
            "h",
            "value",
            "max_value",
            "color_fg",
            "color_bg"
          ],
          "decorators": [],
          "start_line": 10,
          "end_line": 16,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_compass",
          "args": [
            "surface",
            "rect",
            "player_px",
            "pois_world",
            "camera"
          ],
          "decorators": [],
          "start_line": 18,
          "end_line": 32,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw_hud",
          "args": [
            "screen"
          ],
          "decorators": [],
          "start_line": 35,
          "end_line": 56,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "math",
        "pygame",
        "ui.theme",
        "core.strings"
      ],
      "uses_pygame": false,
      "source_code": "\n# ui/hud.py — HUD with i18n for labels\nimport math, pygame\nfrom ui.theme import get_font\nfrom core.strings import t\n\nBAR_W, BAR_H = 240, 12\nBAR_GAP = 8\n\ndef _draw_bar(surface, x, y, w, h, value, max_value, color_fg=(200,60,60), color_bg=(40,40,50)):\n    pygame.draw.rect(surface, color_bg, (x, y, w, h), border_radius=4)\n    frac = 0.0 if max_value<=0 else max(0.0, min(1.0, float(value)/float(max_value)))\n    fw = int(w * frac)\n    if fw > 0:\n        pygame.draw.rect(surface, color_fg, (x, y, fw, h), border_radius=4)\n    pygame.draw.rect(surface, (20,20,26), (x, y, w, h), 1, border_radius=4)\n\ndef _compass(surface, rect, player_px, pois_world, camera):\n    x, y, w, h = rect\n    pygame.draw.rect(surface, (18,18,24), rect, border_radius=6)\n    pygame.draw.rect(surface, (60,60,80), rect, 1, border_radius=6)\n    cy = y + h//2\n    pygame.draw.line(surface, (90,90,120), (x+8, cy), (x+w-8, cy), 1)\n    for i, (wx, wy, label) in enumerate(pois_world or []):\n        dx = wx - player_px[0]\n        dy = wy - player_px[1]\n        if dx == 0 and dy == 0:\n            continue\n        ang = math.atan2(dy, dx)  # -pi..pi\n        tfrac = (ang + math.pi) / (2*math.pi)  # 0..1\n        cx = x + int(tfrac * w)\n        pygame.draw.line(surface, (240,220,160), (cx, y+4), (cx, y+h-4), 2)\n\n\ndef draw_hud(screen, *, lang: str, vitals, vitals_max, gold, compass_pois, player_px, camera, quest_hint: str | None = None):\n    sw, sh = screen.get_size()\n    font = get_font(20)\n    panel = pygame.Surface((sw, 72), pygame.SRCALPHA)\n    x0, y0 = 16, 12\n    _draw_bar(panel, x0, y0, BAR_W, BAR_H, vitals.get('HP',0), vitals_max.get('HP',0), (200,60,60))\n    _draw_bar(panel, x0, y0+BAR_H+BAR_GAP, BAR_W, BAR_H, vitals.get('STA',0), vitals_max.get('STA',0), (100,180,90))\n    _draw_bar(panel, x0, y0+2*(BAR_H+BAR_GAP), BAR_W, BAR_H, vitals.get('MP',0), vitals_max.get('MP',0), (90,140,220))\n    # Gold\n    label_gold = t('hud.gold', lang)\n    gsurf = font.render(f\"{label_gold}: {int(gold)}\", True, (230,230,230))\n    panel.blit(gsurf, (x0, y0+3*(BAR_H+BAR_GAP)+6))\n    # Compass (top center)\n    cw = min(520, sw-360)\n    ch = 18\n    compass_rect = (sw//2 - cw//2, 10, cw, ch)\n    _compass(panel, compass_rect, player_px, compass_pois, camera)\n    # Quest hint (optional)\n    if quest_hint:\n        q = get_font(22).render(quest_hint, True, (240,220,160))\n        panel.blit(q, q.get_rect(center=(sw//2, 48)))\n    screen.blit(panel, (0,0))\n"
    },
    {
      "path": "ui\\layout.py",
      "loc": 18,
      "classes": [],
      "functions": [
        {
          "name": "pos_frac",
          "args": [
            "screen",
            "x_frac",
            "y_frac"
          ],
          "decorators": [],
          "start_line": 4,
          "end_line": 6,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "stack_right",
          "args": [
            "screen",
            "n"
          ],
          "decorators": [],
          "start_line": 8,
          "end_line": 12,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "safe_area",
          "args": [
            "screen",
            "margin_frac"
          ],
          "decorators": [],
          "start_line": 14,
          "end_line": 17,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "typing"
      ],
      "uses_pygame": true,
      "source_code": "import pygame\nfrom typing import List, Tuple\n\ndef pos_frac(screen: pygame.Surface, x_frac: float, y_frac: float) -> tuple[int, int]:\n    sw, sh = screen.get_size()\n    return int(sw * x_frac), int(sh * y_frac)\n\ndef stack_right(screen: pygame.Surface, n: int, *, start_y_frac: float = 0.32, gap_px: int = 54, right_x_frac: float = 0.82) -> List[Tuple[int, int]]:\n    sw, sh = screen.get_size()\n    x = int(sw * right_x_frac)\n    y = int(sh * start_y_frac)\n    return [(x, y + i * gap_px) for i in range(n)]\n\ndef safe_area(screen: pygame.Surface, margin_frac: float = 0.06) -> pygame.Rect:\n    sw, sh = screen.get_size()\n    m = int(min(sw, sh) * margin_frac)\n    return pygame.Rect(m, m, sw - 2 * m, sh - 2 * m)\n"
    },
    {
      "path": "ui\\options_menu.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "ui\\pause_menu.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "ui\\theme.py",
      "loc": 18,
      "classes": [],
      "functions": [
        {
          "name": "get_font",
          "args": [
            "size"
          ],
          "decorators": [],
          "start_line": 12,
          "end_line": 17,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame"
      ],
      "uses_pygame": true,
      "source_code": "import pygame\nCOLORS = {\n    'bg': (8, 10, 14),\n    'menu_item': (200, 200, 200),\n    'menu_sel': (255, 255, 210),\n    'hint': (180, 180, 180),\n    'heading': (236, 200, 120),\n}\nSPACING = {'menu_gap': 56}\n_FONT_CACHE: dict[int, pygame.font.Font] = {}\n\ndef get_font(size: int = 40) -> pygame.font.Font:\n    if not pygame.font.get_init():\n        pygame.font.init()\n    if size not in _FONT_CACHE:\n        _FONT_CACHE[size] = pygame.font.SysFont('serif', size)\n    return _FONT_CACHE[size]\n"
    },
    {
      "path": "ui\\widgets.py",
      "loc": 41,
      "classes": [
        {
          "name": "RightMenuList",
          "start_line": 4,
          "end_line": 40,
          "methods": [
            {
              "name": "__init__",
              "args": [
                "self",
                "font"
              ],
              "decorators": [],
              "start_line": 5,
              "end_line": 9,
              "draw_suspect": false
            },
            {
              "name": "update",
              "args": [
                "self",
                "dt"
              ],
              "decorators": [],
              "start_line": 10,
              "end_line": 11,
              "draw_suspect": false
            },
            {
              "name": "_get_arrow_for_height",
              "args": [
                "self",
                "h"
              ],
              "decorators": [],
              "start_line": 12,
              "end_line": 19,
              "draw_suspect": false
            },
            {
              "name": "draw",
              "args": [
                "self",
                "screen",
                "options",
                "selected",
                "x_frac",
                "y_frac",
                "gap",
                "color_sel",
                "color_norm"
              ],
              "decorators": [],
              "start_line": 20,
              "end_line": 40,
              "draw_suspect": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "args": [
            "self",
            "font"
          ],
          "decorators": [],
          "start_line": 5,
          "end_line": 9,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "update",
          "args": [
            "self",
            "dt"
          ],
          "decorators": [],
          "start_line": 10,
          "end_line": 11,
          "draw_suspect": false,
          "is_update": true,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "_get_arrow_for_height",
          "args": [
            "self",
            "h"
          ],
          "decorators": [],
          "start_line": 12,
          "end_line": 19,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        },
        {
          "name": "draw",
          "args": [
            "self",
            "screen",
            "options",
            "selected",
            "x_frac",
            "y_frac",
            "gap",
            "color_sel",
            "color_norm"
          ],
          "decorators": [],
          "start_line": 20,
          "end_line": 40,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": true,
          "is_handle_events": false
        }
      ],
      "imports": [
        "math",
        "pygame",
        "core.asset",
        "ui.theme"
      ],
      "uses_pygame": false,
      "source_code": "import math, pygame\nfrom core.asset import load_image_strict\nfrom ui.theme import COLORS\nclass RightMenuList:\n    def __init__(self, font: pygame.font.Font, *, arrow_path='ui/selection_arrow.png'):\n        self.font = font\n        self._t = 0.0\n        self.arrow_img = load_image_strict(arrow_path)\n        self._arrow_cache = {}\n    def update(self, dt: float):\n        self._t += dt\n    def _get_arrow_for_height(self, h: int):\n        if not self.arrow_img:\n            return None\n        key = int(h)\n        if key not in self._arrow_cache:\n            w = int(h * 0.9)\n            self._arrow_cache[key] = pygame.transform.smoothscale(self.arrow_img, (w, h))\n        return self._arrow_cache[key]\n    def draw(self, screen: pygame.Surface, options, selected: int, x_frac=0.82, y_frac=0.35, gap=56, color_sel=COLORS['menu_sel'], color_norm=COLORS['menu_item']):\n        sw, sh = screen.get_size()\n        x = int(sw * x_frac)\n        y = int(sh * y_frac)\n        bob = int(3 * math.sin(self._t * 5.0))\n        for i, text in enumerate(options):\n            col = color_sel if i == selected else color_norm\n            surf = self.font.render(text, True, col)\n            rect = surf.get_rect(topright=(x, y))\n            screen.blit(surf, rect)\n            if i == selected:\n                ah = int(self.font.get_height() * 0.8)\n                arrow = self._get_arrow_for_height(ah)\n                if arrow:\n                    arect = arrow.get_rect(midright=(rect.left - 14, rect.centery + bob))\n                    screen.blit(arrow, arect)\n                else:\n                    mid = (rect.left - 12, rect.centery + bob)\n                    pts = [(mid[0]-12, mid[1]-10), (mid[0]-12, mid[1]+10), (mid[0], mid[1])]\n                    pygame.draw.polygon(screen, (240,220,160), pts)\n            y += gap\n"
    },
    {
      "path": "ui\\__init__.py",
      "loc": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": "pass\n"
    },
    {
      "path": "main.py",
      "loc": 42,
      "classes": [],
      "functions": [
        {
          "name": "main",
          "args": [],
          "decorators": [],
          "start_line": 14,
          "end_line": 38,
          "draw_suspect": false,
          "is_update": false,
          "is_draw": false,
          "is_handle_events": false
        }
      ],
      "imports": [
        "pygame",
        "sys",
        "core.config",
        "core.state_manager",
        "gameplay.scene_start",
        "systems.audio",
        "pygame",
        "core.settings",
        "core.state_manager",
        "gameplay.scene_start"
      ],
      "uses_pygame": true,
      "source_code": "\nimport pygame, sys\nfrom core.config import SCREEN_SIZE, FPS\nfrom core.state_manager import StateManager\nfrom gameplay.scene_start import SceneStart\nfrom systems.audio import ensure_audio\n\n# main.py – exemplo\nimport pygame\nfrom core.settings import load_settings, save_settings\nfrom core.state_manager import StateManager\nfrom gameplay.scene_start import SceneStart\n\ndef main():\n    pygame.init()\n    st = load_settings()\n    size = tuple(st.get('resolution', [1280,720]))\n    screen = pygame.display.set_mode(size)  # ideal: pygame.RESIZABLE se quiser\n    clock = pygame.time.Clock()\n    fps_cap = int(st.get('fps', 60))\n\n    mgr = StateManager()\n    mgr.switch_to(SceneStart(mgr))\n\n    while mgr.running:\n        dt = clock.tick(fps_cap) / 1000.0\n        events = pygame.event.get()\n        for e in events:\n            if e.type == pygame.QUIT:\n                mgr.running = False\n        if mgr.current_scene:\n            if hasattr(mgr.current_scene, 'handle'):\n                mgr.current_scene.handle(events)\n            if hasattr(mgr.current_scene, 'update'):\n                mgr.current_scene.update(dt)\n            if hasattr(mgr.current_scene, 'draw'):\n                mgr.current_scene.draw(screen)\n        pygame.display.flip()\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\attack_0.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\attack_1.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\attack_2.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\attack_3.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\idle_0.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\run_0.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\run_1.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\run_2.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\run_3.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\walk_0.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\walk_1.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\walk_2.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\actors\\Humano\\Feminino\\Assassino\\walk_3.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\player\\player_128.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_128x64_v01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_128x64_v02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_128x64_v03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_128x64_v04.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_128x64_v05.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\grass\\grass_128x64_v06.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\dirt_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\dirt_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\dirt_03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\path_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\path_03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\snow_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\snow_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\snow_03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\water_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\water_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\ground\\water_03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\bush_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\bush_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\fence_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\fence_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\flower_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\flower_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\log_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\log_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\rock_large_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\rock_large_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\rock_large_03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\rock_small_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\rock_small_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\rock_small_03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\props\\sign_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\terrain\\rocky_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\terrain\\snow_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\trees\\tree_oak_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\trees\\tree_pine_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\trees\\tree_pine_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\village\\house_01.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\village\\house_02.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\village\\house_03.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\tiles\\village\\house_04.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\ui\\main_menu.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\ui\\selection_arrow.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\ui\\selection_player.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    },
    {
      "path": "assets\\ui\\start_screen.png",
      "loc": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "uses_pygame": false,
      "source_code": null
    }
  ]
}